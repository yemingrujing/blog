{
    "demo": [
        {
            "id": 1,
            "title": "demo1",
            "content": "从零开始建博客"
        },
        {
            "id": 2,
            "title": "demo2",
            "content": "从一开始建博客"
        }
    ],
    "article": [
        {
            "id": 1,
            "title": "文章一",
            "content": "夜明如镜的文章一"
        },
        {
            "id": 2,
            "title": "文章二",
            "content": "夜明如镜的文章二"
        }
    ],
    "news": [
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/28",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/28/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/28/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/28/events",
            "html_url": "https://github.com/Will0319/blog/issues/28",
            "id": 422727016,
            "node_id": "MDU6SXNzdWU0MjI3MjcwMTY=",
            "number": 28,
            "title": "[重要通知!]博客升级2.0",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1324464290,
                    "node_id": "MDU6TGFiZWwxMzI0NDY0Mjkw",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/GoodBye",
                    "name": "GoodBye",
                    "color": "b70c3d",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2019-03-19T13:18:32Z",
            "updated_at": "2019-04-18T07:29:48Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 始\r\n\r\n博客升级的原因在于原先此React博客是用于学习服务器部署以及记录一些自己平常遇到的一些问题，后来发现SEO上并不好，使用了SSR框架重构后也不太理想。以致萌发PHP重构的想法，顺便练练早已生疏的PHP。\r\n\r\n### 末\r\n\r\n至此 此博客寿命结束，欢迎去新博客中进行评论哦~\r\n\r\n升级2.0啦~\r\n\r\n新地址：[博客2.0](http://www.yx319.cn)"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/26",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/26/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/26/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/26/events",
            "html_url": "https://github.com/Will0319/blog/issues/26",
            "id": 401684105,
            "node_id": "MDU6SXNzdWU0MDE2ODQxMDU=",
            "number": 26,
            "title": "antd-moblie在create-react-app中安装使用",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                },
                {
                    "id": 1170306869,
                    "node_id": "MDU6TGFiZWwxMTcwMzA2ODY5",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E7%A7%BB%E5%8A%A8%E7%AB%AF",
                    "name": "移动端",
                    "color": "fbca04",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2019-01-22T09:58:51Z",
            "updated_at": "2019-01-22T10:01:36Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n\r\n最近着手react+jsbridge搭建一个安卓及IOS均可使用的APP，为什么没用RN呢… 因为暂不熟练，扛不住风险呀。那么既然是套壳，那就很轻松了，记录一下目前搭建项目遇到的一些问题。\r\n\r\n### 脚手架创建项目并且引入antd-moblie\r\n\r\n先按照官方的教程走一遍  \r\n\r\n用create-react-app创建一个项目，引入antd-mobile  \r\n\r\n```\r\ncreate-react-app antd-mobile-demo\r\ncd antd-mobile-demo\r\n\r\nnpm install antd-mobile --save\r\n```\r\n\r\n接着引入antd-moblie并且实现按需加载。  \r\n\r\n推荐使用babel-plugin-import插件。配置完之后babel-plugin-import会帮你自动加载js和css。  \r\n\r\n```\r\nnpm i --save babel-plugin-import\r\n```\r\n\r\n安装了之后，修改package.js文件，如下  \r\n\r\n```\r\n\"scripts\": {\r\n-   \"start\": \"react-scripts start\",\r\n+   \"start\": \"react-app-rewired start\",\r\n-   \"build\": \"react-scripts build\",\r\n+   \"build\": \"react-app-rewired build\",\r\n-   \"test\": \"react-scripts test --env=jsdom\",\r\n+   \"test\": \"react-app-rewired test --env=jsdom\",\r\n}\r\n```\r\n\r\n最后还需要在项目的根目录添加一个config-overrides.js文件，顾名思义就是重写配置的意思。把babel-plugin-import插件引入。  \r\n\r\n```\r\nconst { injectBabelPlugin } = require('react-app-rewired');\r\nmodule.exports = function override(config, env) {\r\n      config = injectBabelPlugin(['import', { libraryName: 'antd-mobile', style: 'css' }], config);\r\n      return config;\r\n};\r\n```\r\n\r\n引用的时候直接引入要用的模块即可：\r\n\r\n```\r\nimport {DatePicker, Button} from 'antd-mobile';\r\n<Button type=\"primary\">按钮</Button>\r\n```  \r\n\r\n> 如果不使用react-app-rewired插件重新配置webpack，也可以在根目录新建.babelrc文件添加babel-plugin-import插件配置。  \r\n\r\n```\r\n{\r\n  \"plugins\": [\r\n    [\r\n      \"import\",\r\n      {\r\n        \"libraryName\": \"antd-mobile\",\r\n        \"style\": \"css\"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```  \r\n\r\n### 启动时提示找不到模块\r\n\r\n原因暂时未知，不过我们只需要根据提示再次安装缺少的模块就可以了。\r\n\r\n```\r\nnpm i react-script --save\r\nnpm i react --save\r\nnpm i react-dom --save\r\n```  \r\n\r\n### 启动报错\r\n\r\n提示injectBabelPlugin is not a function。解决方法如下，把react-app-rewired 进行降级后可以了。\r\n\r\n```\r\ncnpm i react-app-rewired@2.0.2-next.0\r\n```\r\n\r\n### 对入口页面（index.html）进行一些有关移动端的相关配置\r\n\r\n```\r\n<script src=\"https://as.alipayobjects.com/g/component/fastclick/1.0.6/fastclick.js\"></script>\r\n<script>\r\n    if ('addEventListener' in document) {\r\n      document.addEventListener('DOMContentLoaded', function() {\r\n        FastClick.attach(document.body);\r\n      }, false);\r\n    }\r\n    if(!window.Promise) {\r\n      document.writeln('<script src=\"https://as.alipayobjects.com/g/component/es6-promise/3.2.2/es6-promise.min.js\"'+'>'+'<'+'/'+'script>');\r\n    }\r\n</script>\r\n```\r\n\r\n* fastclick.js是解决移动端300ms延迟的方案。\r\n\r\n* 有些浏览器不支持promise，需要引入es6-promise支持。\r\n\r\n### 打开create-react-app隐藏配置报错\r\n\r\nThis git repository has untracked files or uncommitted changes:    \r\n\r\n主要问题是脚手架添加.gitgnore文件，但是却没有本地仓库  \r\n\r\n```\r\ngit init\r\ngit add .\r\ngit commit -m 'Saving before ejecting'\r\nnpm run eject\r\n```\r\n以上就可以运行了\r\n\r\n### 总结\r\n\r\n项目中遇到了其他问题再来此处添加记录。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/25",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/25/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/25/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/25/events",
            "html_url": "https://github.com/Will0319/blog/issues/25",
            "id": 394746101,
            "node_id": "MDU6SXNzdWUzOTQ3NDYxMDE=",
            "number": 25,
            "title": "在一台Mac上不同平台同时使用多个Git账号",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1166515809,
                    "node_id": "MDU6TGFiZWwxMTY2NTE1ODA5",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Git%20shell",
                    "name": "Git shell",
                    "color": "744bb7",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-12-29T01:03:16Z",
            "updated_at": "2018-12-29T01:13:37Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n\r\n有时候我们可能需要在一太电脑上使用多个Git账户的情况，这时候我们就需要针对多个平台和账户进行不同的设置。 \r\n\r\n### 思路 \r\n\r\n同时管理多个SSH key。 \r\n\r\n### 解决方案 \r\n\r\n这里使用one two两个账户进行举例  \r\n\r\n注意在生成多个SSH key的时候一定要在~/.ssh目录下进行，否则生成的SSHkey不会再~/.ssh目录下。 以下有操作都是在~/.ssh目录下进行的。 在生成之前尽量删除此目录下的所有文件再进行，以免出现不必要的问题。\r\n\r\n```\r\nssh-keygen -t rsa -C \"one@email.com\"\r\n```\r\n\r\n```\r\nssh-keygen -t rsa -C \"two@email.com\"\r\n```\r\n\r\n复制代码再输入命令行的时候在第一次提示Enter file in which to save the key的时候对ssh文件进行重命名（idrsaone和idrsatwo），这是就会生成一下目录中的四个文件。  \r\n  \r\n```\r\nid_rsa_one\r\nid_rsa_one.pub\r\nid_res_two\r\nid_rsa_two.pub\r\n```\r\n\r\n两份包含私钥和公钥的4个文件。 添加私钥 在对应平台添加私钥的地方，把两个账号生成的私钥添加进去。 \r\n\r\n#### 获取私钥\r\n\r\n```\r\ncat ~/.ssh/id_rsa_one.pub\r\n```\r\n\r\n```\r\ncat ~/.ssh/id_rsa_two.pub\r\n```\r\n\r\n其中（idrsaone.pub和idrsatwo.pub）是之前对的ssh文件重命名的文件名 \r\n\r\n#### 创建config文件 \r\n\r\n```\r\ncat ~/.ssh/id_rsa_one.pub\r\n```\r\n\r\n```\r\ncat ~/.ssh/id_rsa_two.pub\r\n```\r\n\r\n其中（idrsaone.pub和idrsatwo.pub）是之前对的ssh文件重命名的文件名 \r\n\r\n#### 创建config文件 \r\n\r\n在~/.ssh目录下创建一个config文件\r\n\r\n```\r\ntouch config\r\n```\r\n\r\n会在~/.ssh目录下生成一个空的config文件，我们在文件中添加以下内容。\r\n\r\n```\r\n#git server one\r\n\r\nHost\r\n one.aliyun.com #别名\r\n\r\nHostname\r\n code.aliyun.com #真实域名\r\n\r\nPreferredAuthentications\r\n publickey\r\n\r\nIdentityFile\r\n ~/.ssh/id_rsa_one #ssh 文件路径\r\n\r\nUser\r\n one\r\n\r\n#git server two\r\n\r\nHost\r\n two.aliyun.com\r\n\r\nHostname\r\n code.aliyun.com\r\n\r\nPreferredAuthentications\r\n publickey\r\n\r\nIdentityFile\r\n ~/.ssh/id_rsa_two\r\n\r\nUser\r\n two\r\n```\r\n\r\n#### 远程测试【可跳过】\r\n\r\n```\r\nssh –T one.aliyun.com\r\n```\r\n\r\n```\r\nssh –T two.aliyun.com\r\n```\r\n\r\n#### 使用\r\n\r\nclone到本地   \r\n\r\n原来的写法\r\n\r\n```\r\n  git@code.aliyun.com:项目路径.git\r\n```\r\n\r\n现在的写法\r\n\r\n```\r\ngit clone git@one.github.com:项目路径.git\r\ngit clone git@two.github.com:项目路径.git\r\n```\r\n\r\n给仓库设置局部用户名和邮箱【可不设置】\r\n\r\n```\r\ngit config user.name \"one_name\";git config user.email \"one_email\"\r\n\r\ngit config user.name \"two_name\"; git config user.email \"two_email\"\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/24",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/24/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/24/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/24/events",
            "html_url": "https://github.com/Will0319/blog/issues/24",
            "id": 393735275,
            "node_id": "MDU6SXNzdWUzOTM3MzUyNzU=",
            "number": 24,
            "title": "手机端项目问题总结",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1132311411,
                    "node_id": "MDU6TGFiZWwxMTMyMzExNDEx",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Css",
                    "name": "Css",
                    "color": "f78011",
                    "default": false
                },
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                },
                {
                    "id": 1170306869,
                    "node_id": "MDU6TGFiZWwxMTcwMzA2ODY5",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E7%A7%BB%E5%8A%A8%E7%AB%AF",
                    "name": "移动端",
                    "color": "fbca04",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-12-23T09:17:57Z",
            "updated_at": "2018-12-27T02:04:34Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n\r\n最近做了手机端项目（vue）遇到了一些pc端所没有遇到的问题，在这里总结并且记录。\r\n\r\n### 手机两次触摸放大缩量禁用\r\n\r\n在index.html入口定义视口，禁用一下缩放。\r\n\r\n```\r\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\">\r\n```\r\n\r\n### 样式问题\r\n\r\n首先是样式问题，各种浏览器的样式本身就不统一，在手机上浏览则会遇到更多的问题，这里做了一个reset.css来重置整个浏览器的样式。以解决各个浏览器样式问题。\r\n\r\n```css\r\n@charset \"utf-8\";html{background-color:#fff;color:#000;font-size:12px}\r\nbody,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,figure,form,fieldset,legend,input,textarea,button,p,blockquote,th,td,pre,xmp{margin:0;padding:0}\r\nbody,input,textarea,button,select,pre,xmp,tt,code,kbd,samp{line-height:1.5;font-family:tahoma,arial,\"Hiragino Sans GB\",simsun,sans-serif}\r\nh1,h2,h3,h4,h5,h6,small,big,input,textarea,button,select{font-size:100%}\r\nh1,h2,h3,h4,h5,h6{font-family:tahoma,arial,\"Hiragino Sans GB\",\"微软雅黑\",simsun,sans-serif}\r\nh1,h2,h3,h4,h5,h6,b,strong{font-weight:normal}\r\naddress,cite,dfn,em,i,optgroup,var{font-style:normal}\r\ntable{border-collapse:collapse;border-spacing:0;text-align:left}\r\ncaption,th{text-align:inherit}\r\nul,ol,menu{list-style:none}\r\nfieldset,img{border:0}\r\nimg,object,input,textarea,button,select{vertical-align:middle}\r\narticle,aside,footer,header,section,nav,figure,figcaption,hgroup,details,menu{display:block}\r\naudio,canvas,video{display:inline-block;*display:inline;*zoom:1}\r\nblockquote:before,blockquote:after,q:before,q:after{content:\"\\0020\"}\r\ntextarea{overflow:auto;resize:vertical}\r\ninput,textarea,button,select,a{outline:0 none;border: none;}\r\nbutton::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}\r\nmark{background-color:transparent}\r\na,ins,s,u,del{text-decoration:none}\r\nsup,sub{vertical-align:baseline}\r\nhtml {overflow-x: hidden;height: 100%;font-size: 50px;-webkit-tap-highlight-color: transparent;}\r\nbody {font-family: Arial, \"Microsoft Yahei\", \"Helvetica Neue\", Helvetica, sans-serif;color: #333;font-size: .28em;line-height: 1;-webkit-text-size-adjust: none;}\r\nhr {height: .02rem;margin: .1rem 0;border: medium none;border-top: .02rem solid #cacaca;}\r\na {color: #25a4bb;text-decoration: none;\r\n```\r\n\r\n### 移动端1像素问题\r\n\r\n在有的手机中，分辨率较高，是二倍屏，三倍屏。这问题就出现了，在代码中写的一像素但是在多倍屏中会显示为多像素。问题解决的方案是利用缩放来解决一像素问题。下面放代码啦。\r\n\r\n```css\r\n@charset \"utf-8\";\r\n.border,\r\n.border-top,\r\n.border-right,\r\n.border-bottom,\r\n.border-left,\r\n.border-topbottom,\r\n.border-rightleft,\r\n.border-topleft,\r\n.border-rightbottom,\r\n.border-topright,\r\n.border-bottomleft {\r\n    position: relative;\r\n}\r\n.border::before,\r\n.border-top::before,\r\n.border-right::before,\r\n.border-bottom::before,\r\n.border-left::before,\r\n.border-topbottom::before,\r\n.border-topbottom::after,\r\n.border-rightleft::before,\r\n.border-rightleft::after,\r\n.border-topleft::before,\r\n.border-topleft::after,\r\n.border-rightbottom::before,\r\n.border-rightbottom::after,\r\n.border-topright::before,\r\n.border-topright::after,\r\n.border-bottomleft::before,\r\n.border-bottomleft::after {\r\n    content: \"\\0020\";\r\n    overflow: hidden;\r\n    position: absolute;\r\n}\r\n/* border\r\n * 因，边框是由伪元素区域遮盖在父级\r\n * 故，子级若有交互，需要对子级设置\r\n * 定位 及 z轴\r\n */\r\n.border::before {\r\n    box-sizing: border-box;\r\n    top: 0;\r\n    left: 0;\r\n    height: 100%;\r\n    width: 100%;\r\n    border: 1px solid #eaeaea;\r\n    transform-origin: 0 0;\r\n}\r\n.border-top::before,\r\n.border-bottom::before,\r\n.border-topbottom::before,\r\n.border-topbottom::after,\r\n.border-topleft::before,\r\n.border-rightbottom::after,\r\n.border-topright::before,\r\n.border-bottomleft::before {\r\n    left: 0;\r\n    width: 100%;\r\n    height: 1px;\r\n}\r\n.border-right::before,\r\n.border-left::before,\r\n.border-rightleft::before,\r\n.border-rightleft::after,\r\n.border-topleft::after,\r\n.border-rightbottom::before,\r\n.border-topright::after,\r\n.border-bottomleft::after {\r\n    top: 0;\r\n    width: 1px;\r\n    height: 100%;\r\n}\r\n.border-top::before,\r\n.border-topbottom::before,\r\n.border-topleft::before,\r\n.border-topright::before {\r\n    border-top: 1px solid #eaeaea;\r\n    transform-origin: 0 0;\r\n}\r\n.border-right::before,\r\n.border-rightbottom::before,\r\n.border-rightleft::before,\r\n.border-topright::after {\r\n    border-right: 1px solid #eaeaea;\r\n    transform-origin: 100% 0;\r\n}\r\n.border-bottom::before,\r\n.border-topbottom::after,\r\n.border-rightbottom::after,\r\n.border-bottomleft::before {\r\n    border-bottom: 1px solid #eaeaea;\r\n    transform-origin: 0 100%;\r\n}\r\n.border-left::before,\r\n.border-topleft::after,\r\n.border-rightleft::after,\r\n.border-bottomleft::after {\r\n    border-left: 1px solid #eaeaea;\r\n    transform-origin: 0 0;\r\n}\r\n.border-top::before,\r\n.border-topbottom::before,\r\n.border-topleft::before,\r\n.border-topright::before {\r\n    top: 0;\r\n}\r\n.border-right::before,\r\n.border-rightleft::after,\r\n.border-rightbottom::before,\r\n.border-topright::after {\r\n    right: 0;\r\n}\r\n.border-bottom::before,\r\n.border-topbottom::after,\r\n.border-rightbottom::after,\r\n.border-bottomleft::after {\r\n    bottom: 0;\r\n}\r\n.border-left::before,\r\n.border-rightleft::before,\r\n.border-topleft::after,\r\n.border-bottomleft::before {\r\n    left: 0;\r\n}\r\n@media (max--moz-device-pixel-ratio: 1.49), (-webkit-max-device-pixel-ratio: 1.49), (max-device-pixel-ratio: 1.49), (max-resolution: 143dpi), (max-resolution: 1.49dppx) {\r\n    /* 默认值，无需重置 */\r\n}\r\n@media (min--moz-device-pixel-ratio: 1.5) and (max--moz-device-pixel-ratio: 2.49), (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49), (min-device-pixel-ratio: 1.5) and (max-device-pixel-ratio: 2.49), (min-resolution: 144dpi) and (max-resolution: 239dpi), (min-resolution: 1.5dppx) and (max-resolution: 2.49dppx) {\r\n    .border::before {\r\n        width: 200%;\r\n        height: 200%;\r\n        transform: scale(.5);\r\n    }\r\n    .border-top::before,\r\n    .border-bottom::before,\r\n    .border-topbottom::before,\r\n    .border-topbottom::after,\r\n    .border-topleft::before,\r\n    .border-rightbottom::after,\r\n    .border-topright::before,\r\n    .border-bottomleft::before {\r\n        transform: scaleY(.5);\r\n    }\r\n    .border-right::before,\r\n    .border-left::before,\r\n    .border-rightleft::before,\r\n    .border-rightleft::after,\r\n    .border-topleft::after,\r\n    .border-rightbottom::before,\r\n    .border-topright::after,\r\n    .border-bottomleft::after {\r\n        transform: scaleX(.5);\r\n    }\r\n}\r\n@media (min--moz-device-pixel-ratio: 2.5), (-webkit-min-device-pixel-ratio: 2.5), (min-device-pixel-ratio: 2.5), (min-resolution: 240dpi), (min-resolution: 2.5dppx) {\r\n    .border::before {\r\n        width: 300%;\r\n        height: 300%;\r\n        transform: scale(.33333);\r\n    }\r\n    .border-top::before,\r\n    .border-bottom::before,\r\n    .border-topbottom::before,\r\n    .border-topbottom::after,\r\n    .border-topleft::before,\r\n    .border-rightbottom::after,\r\n    .border-topright::before,\r\n    .border-bottomleft::before {\r\n        transform: scaleY(.33333);\r\n    }\r\n    .border-right::before,\r\n    .border-left::before,\r\n    .border-rightleft::before,\r\n    .border-rightleft::after,\r\n    .border-topleft::after,\r\n    .border-rightbottom::before,\r\n    .border-topright::after,\r\n    .border-bottomleft::after {\r\n        transform: scaleX(.33333);\r\n    }\r\n}\r\n```\r\n\r\n### 300毫秒延迟问题\r\n\r\n在某些手机中的点击事件会产生300毫秒的延迟触发点击事件，体验上就不是很好了。为了解决这个问题，需要安装一个第三方模块来解决这个问题。\r\n\r\n```\r\nnpm install fastclick --save\r\n```\r\n\r\n安装后在文件入口引入并且使用。\r\n\r\n```\r\nimport fastClick from 'fastclick';\r\nfastClick.attach(document.body);\r\n```\r\n\r\n### 部分手机浏览器不支持Promise\r\n\r\n安装一个npm包就可以解决\r\n\r\n```\r\ncnpm install babel-polyfill --save\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/23",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/23/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/23/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/23/events",
            "html_url": "https://github.com/Will0319/blog/issues/23",
            "id": 392492369,
            "node_id": "MDU6SXNzdWUzOTI0OTIzNjk=",
            "number": 23,
            "title": "Git常用基础命令",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1166515809,
                    "node_id": "MDU6TGFiZWwxMTY2NTE1ODA5",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Git%20shell",
                    "name": "Git shell",
                    "color": "744bb7",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-12-19T08:36:33Z",
            "updated_at": "2018-12-19T08:37:22Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 用户配置\r\n```bash\r\n$ git config --global user.name 'xxx'  #配置用户名\r\n\r\n$ git config --global user.email 'xxx@xxx.com'  #配置邮箱\r\n```\r\n### 创建版本库\r\n```bash\r\n$ git clone <url>  #克隆远程版本库\r\n\r\n$ git init  #初始化本地版本库\r\n```\r\n### 修改和提交\r\n```bash\r\n$ git status  #查看状态\r\n\r\n$ git diff  #查看变更内容\r\n\r\n$ git add .  #跟踪所有改动过的文件\r\n\r\n$ git add <file>  #跟踪指定的文件\r\n\r\n$ git mv <old> <new>  #文件改名\r\n\r\n$ git rm <file>  #删除文件\r\n\r\n$ git rm --cached <file>  #停止跟踪文件但不删除\r\n\r\n$ git commit -m 'commit message'  #提交所有更新的文件\r\n\r\n$ git commit --amend  #修改最后一次提交\r\n```\r\n### 查看提交历史\r\n```bash\r\n$ git log  #查看提交的历史\r\n\r\n$ git log -p <file>  #查看指定文件的提交历史\r\n\r\n$ git blame <file>  #以列表方式查看指定文件的提交历史\r\n```\r\n### 撤销\r\n```bash\r\n$ git reset --hard HEAD  #撤销工作目录中所有未提交文件的修改内容\r\n\r\n$ git checkout HEAD <file>  #撤销指定的未提交文件的修改内容\r\n\r\n$ git revert <commit>  #撤销指定的提交\r\n```\r\n### 分支与标签\r\n```bash\r\n$ git branch  #显示所有本地分支\r\n\r\n$ git checkout <branch/tag>  #切换到指定分支或标签\r\n\r\n$ git branch <new-branch>  #创建新分支\r\n\r\n$ git branch -d <branch>  #删除本地分支\r\n\r\n$ git tag  #列出所有本地标签\r\n\r\n$ git tag <tagname>  #基于最新提交创建标签\r\n\r\n$ git tag -d <tagname>  #删除标签\r\n```\r\n### 合并与衍合\r\n```bash\r\n$ git merge <branch>  #合并指定分支到当前分支\r\n\r\n$ git rebase <branch>  #衍合指定分支到当前分支\r\n```\r\n### 远程操作\r\n```bash\r\n$ git remote -v  #查看远程版本库信息\r\n\r\n$ git remote show <remote>  #查看指定远程版本库信息\r\n\r\n$ git remote add <remote> <url>  #添加远程版本库\r\n\r\n\r\n$ git fetch <remote>  #从远程库获取代码\r\n\r\n$ git pull <remote> <branch>  #下载代码及快速合并\r\n\r\n$ git push <remote> <branch>  #上传代码及快速合并\r\n\r\n$ git push <remote> :<branch/tag-name>  #删除远程分支或者标签\r\n\r\n$ git push --tags  #上传所有标签\r\n\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/22",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/22/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/22/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/22/events",
            "html_url": "https://github.com/Will0319/blog/issues/22",
            "id": 383019079,
            "node_id": "MDU6SXNzdWUzODMwMTkwNzk=",
            "number": 22,
            "title": "setState异步、同步与进阶",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-11-21T09:06:46Z",
            "updated_at": "2018-12-18T03:08:41Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n\r\n在react中使用最多的应该就是setState吧，不然怎么改变视图！那么你真的了解setState吗？\r\n\r\n### 如何使用setState\r\n\r\n在 React 日常的使用中，一个很重要的点就是，不要直接去修改 state。例如：<span style='color:red'>this.state.count = 1</span>是无法触发 React 去更新视图的。因为React的机制规定，一个state的更新，首先需要调用 setState 方法。\r\n\r\n```\r\nthis.setState({\r\n    count: 1\r\n})\r\n```\r\n\r\n这样便能触发重新渲染。稍有经验的开发者会知道，setState 方法其实是 “异步” 的。即立马执行之后，是无法直接获取到最新的 state 的，需要经过 React 对 state 的所有改变进行合并处理之后，才会去计算新的虚拟dom，再根据最新的虚拟dom去重新渲染真实dom。\r\n\r\n```\r\nclass App extends Component {\r\n\tstate = {\r\n        count: 0\r\n\t}\r\n\r\n    componentDidMount(){\r\n        this.setState({count: this.state.count + 1})\r\n        console.log(this.state.count) // 0\r\n    }\r\n\r\n    render(){\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\n那怎么才能获取到修改后的state呢？React为我们提供了一个回调去实现。\r\n\r\n```\r\n...\r\nthis.setState({count: this.state.count + 1}, ()=>{\r\n    console.log(this.state.count) // 1\r\n})\r\n...\r\n```\r\n\r\n回调里的 state 便是最新的了，原因是该回调的执行时机在于state合并处理之后。如果我们这样去做：\r\n\r\n```\r\n...\r\n\tthis.setState({count: this.state.count + 1})\r\n\tthis.setState({count: this.state.count + 1})\r\n...\r\n```\r\n\r\n实际最终的 count 会等于 1，原因是执行时得到的<span style='color:red'>this.state.count = 0</span>。那怎么实现结果为 2 呢？\r\n\r\n```\r\n...\r\nthis.setState(prevState => {count: prevState.count + 1});\r\nthis.setState(prevState => {count: prevState.count + 1});\r\n...\r\n```\r\n\r\n<span style='color:red'>setState()</span>实际上可以接受一个函数作为参数，函数的首个参数就是上一次的state。  \r\n\r\n以上介绍了<span style='color:red'>setState</span>的三种使用方式，下面我们来看看它们的执行时机是怎样的：\r\n\r\n```\r\n...\r\n\tthis.setState({ count: this.state.count + 1 });\r\n    console.log(\"console: \" + this.state.count); // 0\r\n    this.setState({ count: this.state.count + 1 }, () => {\r\n      console.log(\"console from callback: \" + this.state.count); // 2\r\n    });\r\n    this.setState(prevState => {\r\n      console.log(\"console from func: \" + prevState.count); // 1\r\n      return {\r\n        count: prevState.count + 1\r\n      };\r\n    }, ()=>{\r\n      console.log('last console: '+ this.state.count)\r\n    });\r\n...\r\n```\r\n\r\n执行结果：\r\n\r\n```\r\nconsole: 0 \r\nconsole from func: 1 \r\nconsole from callback: 2\r\nlast console: 2 \r\n```\r\n\r\nReact 其实会维护着一个 state 的更新队列，每次调用 setState 都会先把当前修改的 state 推进这个队列，在最后，React 会对这个队列进行合并处理，然后去执行回调。根据最终的合并结果再去走下面的流程（更新虚拟dom，触发渲染）。\r\n\r\n### setState为什么要设计成异步的\r\n\r\n因为<span style='color:red'>setState()</span>之后无法立马获取最新的 state，给人的感觉便是异步去设置状态。也确实是有异步的感觉（实 际原理后面讲诉）。那么为什么 React 要把状态的更新设计成这种方式呢？直接 <span style='color:red'>this.state.count = 1</span>不好吗？  \r\n\r\n有兴趣的可以点击看看：[github](https://github.com/facebook/react/issues/11527#issuecomment-360199710)  \r\n\r\n这边简单总结下：  \r\n\r\n* 保证内部的一致性：即使<span style='color:red'>state</span>是同步更新，<span style='color:red'>props</span>也不是。（你只有在父组件重新渲染时才能知道props）\r\n* 将<span style='color:red'>state</span>的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实dom，那么它将带来巨大的性能消耗。\r\n\r\n### setState真的是异步吗\r\n\r\n我们先来看一段代码，执行前建议大家先预估下结果：  \r\n\r\n```\r\nclass App extends Component {\r\n  state = {\r\n    count: 0\r\n  };\r\n\r\n  componentDidMount() {\r\n    // 生命周期中调用\r\n    this.setState({ count: this.state.count + 1 });\r\n    console.log(\"lifecycle: \" + this.state.count);\r\n    setTimeout(() => {\r\n      // setTimeout中调用\r\n      this.setState({ count: this.state.count + 1 });\r\n      console.log(\"setTimeout: \" + this.state.count);\r\n    }, 0);\r\n    document.getElementById(\"div2\").addEventListener(\"click\", this.increment2);\r\n  }\r\n\r\n  increment = () => {\r\n    // 合成事件中调用\r\n    this.setState({ count: this.state.count + 1 });\r\n    console.log(\"react event: \" + this.state.count);\r\n  };\r\n\r\n  increment2 = () => {\r\n    // 原生事件中调用\r\n    this.setState({ count: this.state.count + 1 });\r\n    console.log(\"dom event: \" + this.state.count);\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"App\">\r\n        <h2>couont: {this.state.count}</h2>\r\n        <div id=\"div1\" onClick={this.increment}>\r\n          click me and count+1\r\n        </div>\r\n        <div id=\"div2\">click me and count+1</div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n探讨前，我们先简单了解下react的事件机制：react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在<span style='color:red'>jsx</span>中常见的<span style='color:red'>onClick</span>、<span style='color:red'>onChange</span>这些都是合成事件。  \r\n\r\n那么以上4种方式调用<span style='color:red'>setState()</span>，后面紧接着去取最新的state，按之前讲的异步原理，应该是取不到的。然而，<span style='color:red'>setTimeout</span>中调用以及原生事件中调用的话，是可以立马获取到最新的state的。根本原因在于，setState并不是真正意义上的异步操作，它只是模拟了异步的行为。React中会去维护一个标识（<span style='color:red'>isBatchingUpdates</span>），判断是直接更新还是先暂存state进队列。<span style='color:red'>setTimeout</span>以及原生事件都会直接去更新state，因此可以立即得到最新state。而合成事件和React生命周期函数中，是受React控制的，其会将<span style='color:red'>isBatchingUpdates</span>设置为 <span style='color:red'>true</span>，从而走的是类似异步的那一套。\r\n\r\n### 总结\r\n\r\n此处总结是直接引用了：[你真的理解setState吗？](https://juejin.im/post/5b45c57c51882519790c7441#heading-7)\r\n\r\n1. setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。\r\n2. setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\r\n3. setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。\r\n\r\n### 参考\r\n[你真的理解setState吗？](https://juejin.im/post/5b45c57c51882519790c7441#comment)  \r\n\r\n[浅入深出setState（上篇）](https://segmentfault.com/a/1190000015615057)  \r\n\r\n[浅入深出setState（下篇）](https://segmentfault.com/a/1190000015821018)  "
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/21",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/21/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/21/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/21/events",
            "html_url": "https://github.com/Will0319/blog/issues/21",
            "id": 382971248,
            "node_id": "MDU6SXNzdWUzODI5NzEyNDg=",
            "number": 21,
            "title": "十大经典排序算法和使用场景",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                },
                {
                    "id": 1134960476,
                    "node_id": "MDU6TGFiZWwxMTM0OTYwNDc2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E7%AE%97%E6%B3%95",
                    "name": "算法",
                    "color": "ad3051",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-11-21T06:14:45Z",
            "updated_at": "2018-11-21T06:51:27Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n\r\n好长一段时间没有更新的博客了，有点懒惰了最近，这里分享一下近段时间感觉不错的整理后的文章。  \r\n原文地址： [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)\r\n\r\n### 算法分类\r\n\r\n******\r\n\r\n![算法分类](https://github.com/Will0319/ImgFile/blob/master/algorithm/1.png?raw=true)\r\n\r\n### 算法复杂度及相关概念\r\n\r\n******\r\n\r\n> * 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。\r\n> * 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。\r\n> * 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\r\n> * 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\r\n\r\n![算法复杂度](https://github.com/Will0319/ImgFile/blob/master/algorithm/2.png?raw=true)\r\n\r\n### 应用场景\r\n\r\n******\r\n\r\n* (1)若n较小(如n≤50)，可采用直接插入或直接选择排序。\r\n　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。\r\n* (2)若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；\r\n* (3)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。\r\n\r\n快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；  \r\n\r\n堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。  \r\n\r\n若要求排序稳定，则可选用归并排序。但前面介绍的从单个记录起进行两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子序列，然后再两两归并之。因为直接插入排序是稳定 的，所以改进后的归并排序仍是稳定的。  \r\n\r\n### 10种排序\r\n\r\n******\r\n\r\n#### 1.  冒泡排序（Bubble Sort）\r\n\r\n* 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\r\n* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\r\n* 针对所有的元素重复以上的步骤，除了最后一个；\r\n* 重复步骤1~3，直到排序完成。\r\n\r\n![冒泡排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/3.gif?raw=true)\r\n\r\n```\r\nfunction bubbleSort(arr) {\r\n  var len = arr.length;\r\n  for (var i = 0; i < len - 1; i++) {\r\n      for (var j = 0; j < len - 1 - i; j++) {\r\n          if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\r\n              var temp = arr[j+1];        // 元素交换\r\n              arr[j+1] = arr[j];\r\n              arr[j] = temp;\r\n          }\r\n      }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n#### 2.  选择排序（Selection Sort）\r\n\r\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\r\n* 初始状态：无序区为R[1..n]，有序区为空；\r\n* 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前- - 无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\r\n* n-1趟结束，数组有序化了。\r\n\r\n![选择排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/4.gif?raw=true)\r\n\r\n```\r\nfunction selectionSort(arr) {\r\n    var len = arr.length;\r\n    var minIndex, temp;\r\n    for (var i = 0; i < len - 1; i++) {\r\n        minIndex = i;\r\n        for (var j = i + 1; j < len; j++) {\r\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\r\n                minIndex = j;                 // 将最小数的索引保存\r\n            }\r\n        }\r\n        temp = arr[i];\r\n        arr[i] = arr[minIndex];\r\n        arr[minIndex] = temp;\r\n    }\r\n    return arr;\r\n} \r\n```\r\n\r\n表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\r\n\r\n#### 3.  插入排序（Insertion Sort）\r\n\r\n* 从第一个元素开始，该元素可以认为已经被排序；\r\n* 取出下一个元素，在已经排序的元素序列中从后向前扫描；\r\n* 如果该元素（已排序）大于新元素，将该元素移到下一位置；\r\n* 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\r\n* 将新元素插入到该位置后；\r\n* 重复步骤2~5。\r\n\r\n![插入排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/5.gif?raw=true)\r\n\r\n```\r\nfunction insertionSort(arr) {\r\n    var len = arr.length;\r\n    var preIndex, current;\r\n    for (var i = 1; i < len; i++) {\r\n        preIndex = i - 1;\r\n        current = arr[i];\r\n        while (preIndex >= 0 && arr[preIndex] > current) {\r\n            arr[preIndex + 1] = arr[preIndex];\r\n            preIndex--;\r\n        }\r\n        arr[preIndex + 1] = current;\r\n    }\r\n    return arr;\r\n}\r\n```\r\n\r\n#### 4. 希尔排序（Shell Sort）\r\n\r\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\r\n\r\n* 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\r\n* 按增量序列个数k，对序列进行k 趟排序；\r\n* 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\r\n\r\n![希尔排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/6.gif?raw=true)\r\n\r\n```\r\nfunction shellSort(arr) {\r\n    var len = arr.length,\r\n        temp,\r\n        gap = 1;\r\n    while (gap < len / 3) {          // 动态定义间隔序列\r\n        gap = gap * 3 + 1;\r\n    }\r\n    for (gap; gap > 0; gap = Math.floor(gap / 3)) {\r\n        for (var i = gap; i < len; i++) {\r\n            temp = arr[i];\r\n            for (var j = i-gap; j > 0 && arr[j]> temp; j-=gap) {\r\n                arr[j + gap] = arr[j];\r\n            }\r\n            arr[j + gap] = temp;\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n```\r\n\r\n#### 5.归并排序（Merge Sort）\r\n\r\n* 把长度为n的输入序列分成两个长度为n/2的子序列；\r\n* 对这两个子序列分别采用归并排序；\r\n* 将两个排序好的子序列合并成一个最终的排序序列。\r\n\r\n![归并排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/7.gif?raw=true)\r\n\r\n```\r\nfunction mergeSort(arr) {  // 采用自上而下的递归方法\r\n    var len = arr.length;\r\n    if (len < 2) {\r\n        return arr;\r\n    }\r\n    var middle = Math.floor(len / 2),\r\n        left = arr.slice(0, middle),\r\n        right = arr.slice(middle);\r\n    return merge(mergeSort(left), mergeSort(right));\r\n}\r\n\r\nfunction merge(left, right) {\r\n    var result = [];\r\n\r\n    while (left.length>0 && right.length>0) {\r\n        if (left[0] <= right[0]) {\r\n            result.push(left.shift());\r\n        } else {\r\n            result.push(right.shift());\r\n        }\r\n    }\r\n\r\n    while (left.length)\r\n        result.push(left.shift());\r\n\r\n    while (right.length)\r\n        result.push(right.shift());\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。\r\n\r\n#### 6. 快速排序（Quick Sort）\r\n\r\n* 从数列中挑出一个元素，称为 “基准”（pivot）；\r\n* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\r\n* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\r\n\r\n![快速排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/8.gif?raw=true)\r\n\r\n```\r\nfunction quickSort(arr, left, right) {\r\n    var len = arr.length,\r\n        partitionIndex,\r\n        left = typeof left != 'number' ? 0 : left,\r\n        right = typeof right != 'number' ? len - 1 : right;\r\n\r\n    if (left < right) {\r\n        partitionIndex = partition(arr, left, right);\r\n        quickSort(arr, left, partitionIndex-1);\r\n        quickSort(arr, partitionIndex+1, right);\r\n    }\r\n    return arr;\r\n}\r\n\r\nfunction partition(arr, left ,right) {     // 分区操作\r\n    var pivot = left,                      // 设定基准值（pivot）\r\n        index = pivot + 1;\r\n    for (var i = index; i <= right; i++) {\r\n        if (arr[i] < arr[pivot]) {\r\n            swap(arr, i, index);\r\n            index++;\r\n        }       \r\n    }\r\n    swap(arr, pivot, index - 1);\r\n    return index-1;\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n    var temp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n}\r\n```\r\n\r\n#### 7. 堆排序（Heap Sort）\r\n\r\n* 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\r\n* 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\r\n* 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\r\n\r\n![图片标题](https://github.com/Will0319/ImgFile/blob/master/algorithm/9.gif?raw=true)\r\n\r\n```\r\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\r\n\r\nfunction buildMaxHeap(arr) {   // 建立大顶堆\r\n    len = arr.length;\r\n    for (var i = Math.floor(len/2); i >= 0; i--) {\r\n        heapify(arr, i);\r\n    }\r\n}\r\n\r\nfunction heapify(arr, i) {     // 堆调整\r\n    var left = 2 * i + 1,\r\n        right = 2 * i + 2,\r\n        largest = i;\r\n\r\n    if (left < len && arr[left] > arr[largest]) {\r\n        largest = left;\r\n    }\r\n\r\n    if (right < len && arr[right] > arr[largest]) {\r\n        largest = right;\r\n    }\r\n\r\n    if (largest != i) {\r\n        swap(arr, i, largest);\r\n        heapify(arr, largest);\r\n    }\r\n}\r\n\r\nfunction swap(arr, i, j) {\r\n    var temp = arr[i];\r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n}\r\n\r\nfunction heapSort(arr) {\r\n    buildMaxHeap(arr);\r\n\r\n    for (var i = arr.length - 1; i > 0; i--) {\r\n        swap(arr, 0, i);\r\n        len--;\r\n        heapify(arr, 0);\r\n    }\r\n    return arr;\r\n}\r\n```\r\n\r\n#### 8. 计数排序（Counting Sort）\r\n\r\n* 找出待排序的数组中最大和最小的元素；\r\n* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\r\n* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\r\n* 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\r\n\r\n![计数排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/10.gif?raw=true)\r\n\r\n```\r\nfunction countingSort(arr, maxValue) {\r\n    var bucket = new Array(maxValue + 1),\r\n        sortedIndex = 0;\r\n        arrLen = arr.length,\r\n        bucketLen = maxValue + 1;\r\n\r\n    for (var i = 0; i < arrLen; i++) {\r\n        if (!bucket[arr[i]]) {\r\n            bucket[arr[i]] = 0;\r\n        }\r\n        bucket[arr[i]]++;\r\n    }\r\n\r\n    for (var j = 0; j < bucketLen; j++) {\r\n        while(bucket[j] > 0) {\r\n            arr[sortedIndex++] = j;\r\n            bucket[j]--;\r\n        }\r\n    }\r\n\r\n    return arr;\r\n}\r\n```\r\n\r\n计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\r\n\r\n#### 9. 桶排序（Bucket Sort）\r\n\r\n* 设置一个定量的数组当作空桶；\r\n* 遍历输入数据，并且把数据一个一个放到对应的桶里去；\r\n* 对每个不是空的桶进行排序；\r\n* 从不是空的桶里把排好序的数据拼接起来。\r\n\r\n![桶排序](https://github.com/Will0319/ImgFile/blob/master/algorithm/11.png?raw=true)\r\n\r\n```\r\nfunction bucketSort(arr, bucketSize) {\r\n    if (arr.length === 0) {\r\n      return arr;\r\n    }\r\n\r\n    var i;\r\n    var minValue = arr[0];\r\n    var maxValue = arr[0];\r\n    for (i = 1; i < arr.length; i++) {\r\n      if (arr[i] < minValue) {\r\n          minValue = arr[i];                // 输入数据的最小值\r\n      } else if (arr[i] > maxValue) {\r\n          maxValue = arr[i];                // 输入数据的最大值\r\n      }\r\n    }\r\n\r\n    // 桶的初始化\r\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\r\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\r\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  \r\n    var buckets = new Array(bucketCount);\r\n    for (i = 0; i < buckets.length; i++) {\r\n        buckets[i] = [];\r\n    }\r\n\r\n    // 利用映射函数将数据分配到各个桶中\r\n    for (i = 0; i < arr.length; i++) {\r\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\r\n    }\r\n\r\n    arr.length = 0;\r\n    for (i = 0; i < buckets.length; i++) {\r\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\r\n        for (var j = 0; j < buckets[i].length; j++) {\r\n            arr.push(buckets[i][j]);                     \r\n        }\r\n    }\r\n\r\n    return arr;\r\n}\r\n```\r\n\r\n桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\r\n\r\n#### 10. 基数排序（Radix Sort）\r\n\r\n* 取得数组中的最大数，并取得位数；\r\n* arr为原始数组，从最低位开始取每个位组成radix数组；\r\n* 对radix进行计数排序（利用计数排序适用于小范围数的特点）\r\n\r\n![图片标题](https://github.com/Will0319/ImgFile/blob/master/algorithm/12.gif?raw=true)\r\n\r\n```\r\n// LSD Radix Sort\r\nvar counter = [];\r\nfunction radixSort(arr, maxDigit) {\r\n    var mod = 10;\r\n    var dev = 1;\r\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\r\n        for(var j = 0; j < arr.length; j++) {\r\n            var bucket = parseInt((arr[j] % mod) / dev);\r\n            if(counter[bucket]==null) {\r\n                counter[bucket] = [];\r\n            }\r\n            counter[bucket].push(arr[j]);\r\n        }\r\n        var pos = 0;\r\n        for(var j = 0; j < counter.length; j++) {\r\n            var value = null;\r\n            if(counter[j]!=null) {\r\n                while ((value = counter[j].shift()) != null) {\r\n                      arr[pos++] = value;\r\n                }\r\n          }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n```\r\n\r\n基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。  \r\n\r\n基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n>>k，因此额外空间需要大概n个左右。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/20",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/20/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/20/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/20/events",
            "html_url": "https://github.com/Will0319/blog/issues/20",
            "id": 382938658,
            "node_id": "MDU6SXNzdWUzODI5Mzg2NTg=",
            "number": 20,
            "title": "代码整洁之道",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                },
                {
                    "id": 1019382694,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNjk0",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E4%BC%98%E5%8C%96",
                    "name": "优化",
                    "color": "ed7496",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-11-21T03:21:06Z",
            "updated_at": "2018-11-21T03:39:51Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n\r\n最近抽空看完了《代码整洁之道》，并且在目前公司项目中深有感触。就像Jack Reecves所发表的《源码就是设计》：源码就是最好软件设计文档，而其他非代码性的文档只是源码的辅助。那么一份整洁的代码阅读起来就应该是行云流水如同精美好文一般。\r\n\r\n#### 具备什么特性？\r\n\r\n* 变量、函数、类、包、模块命名合理有意义\r\n* 代码结构（格式）清晰\r\n* 必要的合理的注释信息：代码能自解释只是理想，该注释的地方还是免不了\r\n* 合理的异常处理机制\r\n* 有效的日志信息\r\n* 遵循面向对象设计原则  \r\n\r\n> 接下来展示一些好的JS代码应该怎么做。\r\n\r\n#### 避免条件\r\n\r\n这似乎是个不可能完成的任务。大多数人第一次听到这个的时候会说，“没有 if 语句我该怎么办？”回答是在多数情况下都可以使用多态来实现相同的任务。第二个问题通常是，“那太好了，不过我为什么要这么做呢？”答案在于我们之前了解过整洁的概念：一个函数应该只做一件事情。如果你的类和函数有 if 语句，就意味着你的函数做了更多的事。记住，只做一件事。\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\nclass Airplane {\r\n  //...\r\n  getCruisingAltitude() {\r\n    switch (this.type) {\r\n      case '777':\r\n        return getMaxAltitude() - getPassengerCount();\r\n      case 'Air Force One':\r\n        return getMaxAltitude();\r\n      case 'Cessna':\r\n        return getMaxAltitude() - getFuelExpenditure();\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nclass Airplane {\r\n  //...\r\n}\r\n\r\nclass Boeing777 extends Airplane {\r\n  //...\r\n  getCruisingAltitude() {\r\n    return getMaxAltitude() - getPassengerCount();\r\n  }\r\n}\r\n\r\nclass AirForceOne extends Airplane {\r\n  //...\r\n  getCruisingAltitude() {\r\n    return getMaxAltitude();\r\n  }\r\n}\r\n\r\nclass Cessna extends Airplane {\r\n  //...\r\n  getCruisingAltitude() {\r\n    return getMaxAltitude() - getFuelExpenditure();\r\n  }\r\n}\r\n```\r\n\r\n#### 不要过度优化\r\n\r\n现在浏览器在运行时悄悄地做了很多优化工作。很多时候你的优化都是在浪费时间。这里有很好的资源 可以看看哪些优化比较缺乏。把它们作为目标，直到他们能固定下来的时候。\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\n// 在旧浏览器中，每次循环的成本都比较高，因为每次都会重算 `len`。\r\n// 现在浏览器中，这已经被优化了。\r\nfor (var i = 0, len = list.length; i < len; i++) {\r\n  // ...\r\n}\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nfor (var i = 0; i < list.length; i++) {\r\n  // ...\r\n}\r\n```\r\n\r\n#### 用 Object.assign 设置默认对象\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\nvar menuConfig = {\r\n  title: null,\r\n  body: 'Bar',\r\n  buttonText: null,\r\n  cancellable: true\r\n}\r\n\r\nfunction createMenu(config) {\r\n  config.title = config.title || 'Foo'\r\n  config.body = config.body || 'Bar'\r\n  config.buttonText = config.buttonText || 'Baz'\r\n  config.cancellable = config.cancellable === undefined ? config.cancellable : true;\r\n\r\n}\r\n\r\ncreateMenu(menuConfig);\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nvar menuConfig = {\r\n  title: 'Order',\r\n  // User did not include 'body' key\r\n  buttonText: 'Send',\r\n  cancellable: true\r\n}\r\n\r\nfunction createMenu(config) {\r\n  config = Object.assign({\r\n    title: 'Foo',\r\n    body: 'Bar',\r\n    buttonText: 'Baz',\r\n    cancellable: true\r\n  }, config);\r\n\r\n  // 现在 config 等于: {title: \"Foo\", body: \"Bar\", buttonText: \"Baz\", cancellable: true}\r\n  // ...\r\n}\r\n\r\ncreateMenu(menuConfig);\r\n```\r\n\r\n#### 不要写入全局函数\r\n\r\nJavaScript 中全局污染是一件糟糕的事情，因为它可能和另外库发生冲突，然而使用你 API 的用户却不会知道——直到他们在生产中遇到一个异常。来思考一个例子：你想扩展 JavaScript 的原生 Array，使之拥有一个 diff 方法，用来展示两数据之前的区别，这时你会怎么做？你可以给 Array.prototype 添加一个新的函数，但它可能会与其它想做同样事情的库发生冲突。如果那个库实现的 diff 只是比如数组中第一个元素和最后一个元素的异同会发生什么事情呢？这就是为什么最好是使用 ES6 的类语法从全局的 Array 派生一个类来做这件事。\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\nArray.prototype.diff = function(comparisonArray) {\r\n  var values = [];\r\n  var hash = {};\r\n\r\n  for (var i of comparisonArray) {\r\n    hash[i] = true;\r\n  }\r\n\r\n  for (var i of this) {\r\n    if (!hash[i]) {\r\n      values.push(i);\r\n    }\r\n  }\r\n\r\n  return values;\r\n}\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nclass SuperArray extends Array {\r\n  constructor(...args) {\r\n    super(...args);\r\n  }\r\n\r\n  diff(comparisonArray) {\r\n    var values = [];\r\n    var hash = {};\r\n\r\n    for (var i of comparisonArray) {\r\n      hash[i] = true;\r\n    }\r\n\r\n    for (var i of this) {\r\n      if (!hash[i]) {\r\n        values.push(i);\r\n      }\r\n    }\r\n\r\n    return values;\r\n  }\r\n}\r\n```\r\n\r\n#### 避免否定条件\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\nfunction isDOMNodeNotPresent(node) {\r\n  // ...\r\n}\r\n\r\nif (!isDOMNodeNotPresent(node)) {\r\n  // ...\r\n}\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nfunction isDOMNodePresent(node) {\r\n  // ...\r\n}\r\n\r\nif (isDOMNodePresent(node)) {\r\n  // ...\r\n}\r\n```\r\n\r\n#### 删除不用的代码\r\n\r\n不用的代码和重复的代码一样糟糕。在代码库中保留无用的代码是毫无道理的事情。如果某段代码用不到，那就删掉它！如果你以后需要它，仍然可以从代码库的历史版本中找出来。\r\n\r\n#### 不需要日志式的注释\r\n\r\n记住，使用版本控制！没用的代码、注释掉的代码，尤其是日志式的注释。用 git log 来获取历史信息！\r\n\r\n> <span style='color:red'>bad</span>\r\n\r\n```\r\n/**\r\n * 2016-12-20: Removed monads, didn't understand them (RM)\r\n * 2016-10-01: Improved using special monads (JP)\r\n * 2016-02-03: Removed type-checking (LI)\r\n * 2015-03-14: Added combine with type-checking (JR)\r\n */\r\nfunction combine(a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n> <span style='color:#2DC34C'>good</span>\r\n\r\n```\r\nfunction combine(a, b) {\r\n  return a + b;\r\n}\r\n```\r\n\r\n#### 参考\r\n\r\n有兴趣的同学可以去看看原版或者下方资料。  \r\n\r\n1. [英文版](https://github.com/ryanmcdermott/clean-code-javascript/blob/master/README.md)\r\n\r\n2. [中文版](https://www.zcfy.cc/article/clean-code-javascript-readme-md-at-master-ryanmcdermott-clean-code-javascript-github-2273.html)"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/19",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/19/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/19/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/19/events",
            "html_url": "https://github.com/Will0319/blog/issues/19",
            "id": 371819653,
            "node_id": "MDU6SXNzdWUzNzE4MTk2NTM=",
            "number": 19,
            "title": "小程序开发基础知识",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1096698193,
                    "node_id": "MDU6TGFiZWwxMDk2Njk4MTkz",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Wechat",
                    "name": "Wechat",
                    "color": "8BD953",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-10-19T06:11:58Z",
            "updated_at": "2018-10-19T07:20:51Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 准备工作\r\n\r\n******\r\n\r\n小程序开发要先注册小程序账号，有了小程序账号才可以使用开发者工具。小程序是一种特殊的开发形式，里面的 API 和组件都是自己定制的，因此在普通的浏览器中不能预览，要预览功能和页面就需要使用开发者工具。\r\n\r\n##### 注册小程序账号\r\n\r\n先准备一个没有注册过公众号的邮箱，然后访问 [小程序介绍页面](https://mp.weixin.qq.com/cgi-bin/wx?token=&lang=zh_CN)并点击底部的「前往注册」按钮，再按照提示填写个人信息，最后进入邮箱激活账号即可。  \r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/1.jpg?raw=true)\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/2.jpg?raw=true)\r\n\r\n详细流程请参考[官方文档](https://developers.weixin.qq.com/miniprogram/dev/#%E7%94%B3%E8%AF%B7%E5%B8%90%E5%8F%B7)。\r\n\r\n##### 安装开发者工具\r\n\r\n小程序有自己的开发者工具，可以编写代码，实时查看页面和功能效果，还能在开发者工具中进行 debug。小程序开发者工具是使用 NW.js 编写的。  \r\n\r\n开发者工具下载地址：[微信开发者工具](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)。\r\n\r\n##### 使用开发者工具演示 WeUI\r\n\r\n> WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、 progress、 toast、article、actionsheet、icon 等各式组件。  \r\n\r\nWeUI 有两个版本，一个是普通的 [HTML5 版本](https://github.com/Tencent/weui)，另外是[小程序版本](https://github.com/Tencent/weui-wxss)。现在通过 WeUI 来简单学习开发者工具的使用。  \r\n\r\n首先下载 WeUI 源码：  \r\n\r\n```\r\n# https 方式（推荐）\r\ngit clone https://github.com/Tencent/weui-wxss.git\r\n# 或者 ssh 方式\r\ngit clone git@github.com:Tencent/weui-wxss.git\r\n```\r\n\r\n打开开发者工具，使用注册时绑定的微信账号扫码登录，这时在进入的界面中选择「小程序项目」，如果是初次使用小程序开发者工具，没有创建过小程序项目，就会进入下面的页面：  \r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/3.jpg?raw=true)\r\n\r\n在这个页面，先选择我们 clone 下来的 WeUI 项目的 dist 文件夹。对于 AppID 选项，如果已经有了小程序账号，可以在账号后台找到 AppID 并填写上；若还没有注册小程序账号，可以直接在「或使用测试号：」后面单击「小程序」，就会自动填好。然后给项目起个名字，比如「WeUI 演示」，点击确定后就打开了 WeUI 项目。这时候看到的是开发者工具的开发界面，如下图所示，开发界面主要由三部分组成：模拟器、编辑器和调试器。  \r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/4.jpg?raw=true)  \r\n\r\n* 模拟器：提供小程序的运行环境，模拟小程序在手机上的界面效果\r\n* 编辑器：简单 IDE 功能，点击左侧树形菜单可以打开多个文件直接编写保存，做到实时预览效果，但是开发者工具的编辑器做得比较简单，而且使用体验并不好，建议选择自己顺手的 IDE 增加 WXML 和 WXSS 的语法高亮插件等来编辑代码\r\n* 调试器：订制版的 Chrome 开发者工具，提供从页面结构到网络请求等多个面板支持，会用 Chrome DevTools 就很容易上手该工具  \r\n\r\n> Tips： 常用 IDE 推荐\r\n> * VS Code + [minapp 插件](https://marketplace.visualstudio.com/items?itemName=qiu8310.minapp-vscode)\r\n> * Sublime Text 3 + Sublime [wxapp 插件](https://github.com/springlong/Sublime-wxapp/blob/master/docs/README.zh-ch.md)\r\n> * Vim + [wxapp](https://github.com/chemzqm/wxapp.vim)  \r\n\r\n除了三个重要组成部分之外，在开发者工具的顶部还有各种操作按钮。左侧主要是模拟器、编辑器、调试器和小程序云开发控制台的视图开关，可以控制对应视图的开启关闭。\r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/5.jpg?raw=true)    \r\n\r\n中间部分是跟开发、编译、测试和上线相关的各种按钮，我们在开发和测试小程序中会经常使用，最常用的有：  \r\n\r\n* 预览、远程调试：是可以在手机上直接预览效果，开启远程 debug 功能的\r\n* 清缓存：对于一些授权登录、缓存、数据之类的操作，我们需要清理状态和数据，可以通过这个按钮操作\r\n* 上传：如果是创建项目的时候填写了 AppID，那么会出现这个按钮，小程序开发完毕后可以通过这个来上传，上传之后可以在小程序后台申请测试版和审核，审核通过后就可以正式上线了  \r\n\r\n最后介绍的是开发者工具右上角的「详情」。  \r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/6.jpg?raw=true)    \r\n\r\n详情下面主要有三个 Tab：项目设置、域名信息和腾讯云状态。  \r\n\r\n* 项目设置：这个是用得比较多的，可以指定上传代码时候的编译情况，比如支持 ES6 语法、支持 css autoprefixer、代码压缩等\r\n* 域名信息：小程序的 request 等访问的域名采用了白名单形式，在这里可以看到小程序管理后台设置的域名白名单\r\n* 腾讯云状态：可以看到小程序账号和腾讯云的绑定情况  \r\n\r\n#### 小程序开发语言\r\n\r\n******\r\n\r\n小程序的开发语言跟前端开发者比较熟悉的 HTML5 非常相似（甚至相同），小程序的视图层由 WXML 和 WXSS 组成，分别对应 HTML 和 CSS，逻辑层则跟 HTML5 一样，也是 JavaScript 语言实现。  \r\n\r\n* WXML：小程序自己发明的 XML 语法描述，用来构造小程序的页面结构\r\n* WXSS：小程序的页面的样式表语言，描述 WXML 的样式\r\n* JavaScript：小程序 JS 的执行环境并不是普通的 WebView 浏览器，也不是 Node.js 环境，它执行在微信 App 内上下文， 跟 Node.js 一样，也不能像在浏览器内一样对页面 DOM 进行操作  \r\n\r\n> 微信小程序运行在三端：iOS、Android 和用于调试的开发者工具\r\n> * 在 iOS 上，小程序的 JavaScript 代码运行在 JavaScriptCore 中\r\n> * 在 Android 上，小程序的 JavaScript 代码通过 X5 内核来解析\r\n> * 在 开发工具上， 小程序的 JavaScript 代码运行在 NW.js（Chromium 内核） 中  \r\n\r\n除了普通的 JavaScript，小程序还支持一种类似 JS 的 WXS 语言，WXS 对于小程序开发不是必需的，它的主要目的是为了增强 WXML 的数据处理能力而新引入一种技术实现，其实际解析的语言规范还是 JS，并没有引入新的语法，仅仅对 JS 做了上层的封装和限制，所以学习上基本没什么成本，大致了解下开发文档马上就能上手。\r\n\r\n> 对于 WXS 和 JavaScript 的性能比较，官方给出的数据是：由于运行环境的差异，在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍。在 Android 设备上二者运行效率无差异。  \r\n\r\n#### 小程序项目相关知识  \r\n\r\n******\r\n\r\n##### 小程序目录结构  \r\n\r\n小程序项目由配置文件、页面文件、静态资源和其他相关（比如组件、小程序云函数等）内容组成，一般小程序会由四类文件组成：  \r\n\r\n* .json 后缀的 JSON 配置文件\r\n* .wxml 后缀的 WXML 模板文件\r\n* .wxss 后缀的 WXSS 样式文件\r\n* .js 后缀的 JS 脚本逻辑文件  \r\n\r\n小程序项目的目录结构组成没有严格的要求，按照前端项目的经验，一般会分为：配置、页面、静态资源、基础库、组件等多个目录，例如下面的目录结构：  \r\n\r\n```\r\n├── app.js            小程序全局app相关js\r\n├── app.json          小程序配置文件\r\n├── app.wxss          小程序全局app样式\r\n├── cloud-functions   云函数目录\r\n│   ├── decrypt\r\n│   ├── geocoder\r\n│   ├── he-air\r\n│   ├── he-weather\r\n│   ├── jscode2session\r\n│   └── weather\r\n├── components        组件库\r\n│   └── icon\r\n├── images            图片等静态资源\r\n│   └── cloud.jpg\r\n├── pages             页面目录\r\n│   ├── diary\r\n│   └── weather\r\n└── project.config.json  工具项目配置文件\r\n```  \r\n\r\n当然根据不同的项目，可能目录结构不同，但是小程序必需的 app.json 和页面组成是必不可少的。另外，在开发复杂的项目时，我们会用到开发框架或者编译工具，这时候目录结构只需要保证编译之后的目录结构符合规范即可。  \r\n\r\n##### 小程序的配置\r\n\r\n小程序有三个重要的配置，分别放在三个 JSON 文件内：project.config.json（工具项目配置）、app.json（小程序配置）、page.json（单页面配置）  \r\n\r\n* project.config.json：这个是配置项目工具相关的，比如开发者工具的编译设置（是否使用 ES6 语法等）、界面设置，以及云函数相关的 cloudfunctionRoot，详细可以参考[项目配置文件](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)\r\n* app.json：小程序的全局配置，包括了所有页面路径、界面表现、网络超时时间、底部 tab、插件等，常用的两个配置是 window 和 pages，详细配置参考[全局配置](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html)\r\n* page.json：是相对于 app.json 更细粒度的单页面配置，详细参考[页面配置](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE)\r\n\r\n#### 组件和插件\r\n\r\n******\r\n\r\n小程序页面是由各种组件组成的，组件可以类比成原生 HTML5 的标签。\r\n\r\n##### 组件\r\n\r\n小程序内部定义了很多组件，可以对应 HTML5 的标签和基础能力来理解，小程序的组件根据实现不同，可以分为 Web 组件和 Native 组件，Web 组件是由 HTML5 原生 Web 组件封装的组件，比如 view、image 等；Native 组件是为了增强小程序的体验，用客户端技术实现的组件，包括一些交互复杂、原生 Web 组件性能不高的组件，例如 input、map、canvas、video 等。  \r\n\r\n小程序一共提供 8 大类 30 多个组件：  \r\n\r\n* 视图容器：主要是实现页面布局的，对常见的布局形式进行了封装，比如滚动 sroll-view 等\r\n* 基本内容：类似 HTML5 中内容相关的 p、em 等\r\n* 表单相关：要比 HTML5 的 form 表单丰富一些\r\n* 导航：类似 a 标签\r\n* 媒体：类比 HTML5 中的 video、audio 和 img 等，但是提供更标准的界面和更丰富的 API 支持\r\n* 画布：Native 实现的 Canvas\r\n* 地图：结合腾讯地图数据 Native 实现的组件\r\n* 开放能力：这部分组件偏通用和小程序业务  \r\n\r\n##### 自定义组件\r\n\r\n小程序本身支持很多组件，比如地图、按钮等，开发者也可以自己做项目内公共组件，比如我们后面实战部分会介绍做一个 icon 组件，放在 components 目录下面，这样此小程序的任何页面如果要使用这个 icon 公共组件，只需在自己的 page.json 中添加如下字段：  \r\n\r\n```\r\n\"usingComponents\": {\r\n  \"icon\": \"../../components/icon/index\"\r\n}\r\n```  \r\n\r\n添加完成之后，在页面代码中就可以直接使用 <icon> 的 tag 了。[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)有更加详细的介绍。  \r\n\r\n##### 插件\r\n\r\n插件是对一组 JS 接口、自定义组件或页面的封装，用于提供给第三方小程序调用。简单来说，插件是组件的升级版本，组件只能在自己项目中使用，插件则更独立，是可以发布到全网，供其他开发者使用的。例如实战中，笔者使用了一款日历插件，则需要在 app.json 中增加 plugins 字段：\r\n\r\n```\r\n\"plugins\": {\r\n  \"calendar\": {\r\n    \"version\": \"1.1.3\",\r\n    \"provider\": \"wx92c68dae5a8bb046\"\r\n  }\r\n}\r\n```\r\n\r\n如果想开发一个插件，则可以参考[官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html)。\r\n\r\n#### 小程序开发基础\r\n\r\n******\r\n\r\n微信小程序是由数据驱动的开发框架，本小节主要介绍小程序开发中的基础概念和知识。  \r\n\r\n##### 数据驱动  \r\n\r\n微信小程序是数据驱动模型，在 WXML 中可以对页面的数据进行绑定，小程序的 WXML 内使用的是 Mustache 语法，在 {{}} 内可以将变量名包裹起来。 例如：  \r\n\r\n```\r\n<view>{{ message }}</view>\r\n```\r\n\r\n```\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  }\r\n})\r\n```\r\n\r\n但是小程序不支持复杂的表达式，目前支持简单的三元、加减和逻辑判断，如果要使用形如 {{parseInt(num)}} 的函数调用语法，需要 WXS 支持：  \r\n\r\nWXML 内容：  \r\n\r\n```\r\n<wxs src=\"./demo.wxs\" module=\"tools\" />\r\n<view>{{ tools.toNumber(num) }}</view>\r\n```\r\n\r\nWXS 内容：\r\n\r\n```\r\n// demo.wxs\r\nfunction toNumber(n){\r\n  return parseInt(n)\r\n}\r\nmodule.exports.toNumber = toNumber\r\n```\r\n\r\n小程序内对页面的数据修改只能通过 setData 方法，不能使用直接赋值的方式 this.data.key = value：  \r\n\r\n```\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  },\r\n  onLoad(){\r\n    this.setData({\r\n      message: 'hello world~'\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n```\r\n记住：修改页面数据，只能使用 this.setData 修改！\r\n```\r\n\r\n##### 事件绑定和处理\r\n\r\n在小程序内，除了标准 HTML5 中遇见的 touchstart 等事件外，增加了 tap 类的事件，主要包括以下几种：  \r\n\r\n事件名称 | 说明 \r\n------------ | ------------- | \r\ntap | 手指触摸后马上离开  | \r\nlongpress | 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发  | \r\nlongtap | 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）  | \r\n\r\n##### 事件冒泡\r\n\r\n小程序内的事件分为可冒泡和不可冒泡的事件，除了 submit、input 之类的事件，多数是可冒泡的事件，对于事件的绑定，除了 bind* 的方式，还可以通过 catch* 的方式来绑定，两者的区别在于：  \r\n\r\n* bind 不会阻止冒泡，变形写法为 bind:*\r\n* catch 会阻止事件继续冒泡，变形写法为 catch:*  \r\n\r\n##### 事件捕获  \r\n\r\n小程序内，触摸类事件支持捕获阶段，捕获是先于冒泡的触发，绑定捕获事件，可以使用 capture-bind、capture-catch，后者将中断捕获阶段和取消冒泡阶段，下面是官方的示例：  \r\n\r\n> 在下面的代码中，点击 inner view 会先后调用 handleTap2、handleTap4、handleTap3、handleTap1。\r\n\r\n```\r\n<view id=\"outer\" bind:touchstart=\"handleTap1\" capture-bind:touchstart=\"handleTap2\">\r\n  outer view\r\n  <view id=\"inner\" bind:touchstart=\"handleTap3\" capture-bind:touchstart=\"handleTap4\">\r\n    inner view\r\n  </view>\r\n</view>\r\n```\r\n\r\n> 如果将上面代码中的第一个 capture-bind 改为 capture-catch，将只触发 handleTap2。\r\n\r\n```\r\n<view id=\"outer\" bind:touchstart=\"handleTap1\" capture-catch:touchstart=\"handleTap2\">\r\n  outer view\r\n  <view id=\"inner\" bind:touchstart=\"handleTap3\" capture-bind:touchstart=\"handleTap4\">\r\n    inner view\r\n  </view>\r\n</view>\r\n```\r\n\r\n关于事件的详细说明，建议阅读[官方的文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，以获取更大的帮助。\r\n\r\n##### 事件对象\r\n\r\n当事件触发时，处理函数会响应，传入 event 对象，通过 event 对象可以获取事件触发时候的一些信息，包括时间戳、detail 等。  \r\n\r\n因为小程序内的事件绑定都是在 WXML 中实现的，所以传递参数只能通过 WXML 上面的属性值来传递，例如下面的代码中，indexDetail 处理函数需要接收生活指数的名称和详情，来弹出弹层提示，这时候需要在标签上增加 data-xx 这样的属性，data-name 和 data-detail 就是两个属性，通过这两个值，可以在 indexDetail 内 event 对象的 target/currentTarget 的 dataset 获取参数。  \r\n\r\n```\r\n<view class=\"life-style\">\r\n    <view class=\"item\" wx:for=\"{{lifeStyle}}\" data-name=\"{{item.name}}\" data-detail=\"{{item.detail}}\" bindtap=\"indexDetail\">\r\n      <view class=\"title\">\r\n        <icon type=\"{{item.icon}}\"></icon>\r\n        {{item.name}}\r\n      </view>\r\n      <view class=\"content\">{{item.info}}</view>\r\n    </view>\r\n</view>\r\n```\r\n\r\n```\r\n// weather/index.js\r\n// 响应事件的处理函数\r\nindexDetail(e) {\r\n  const {name, detail} = e.currentTarget.dataset\r\n  wx.showModal({\r\n    title: name,\r\n    content: detail,\r\n    showCancel: false\r\n  })\r\n}\r\n```\r\n\r\n按照官方文档，target 和 currentTarget 都有个 dataset，正确获取 dataset 的姿势是使用 currentTarget 的，但是有时候 target 和 currentTarget 的数据又是完全一样的，如果这里使用 target 的话，那么有时候点击会弹出弹窗，有时候不会弹出，这两者究竟是怎样的关系呢？官方的解释有点模棱两可：  \r\n\r\n* target：触发事件的源组件\r\n* currentTarget：事件绑定的当前组件  \r\n\r\n这里笔者做下详细解释：  \r\n\r\n* target：触发事件的源组件，上面的代码中，target 可能是 view.title、view.content、view.item 任意触发事件的组件\r\n* currentTarget：事件绑定的当前组件，上面的代码中，只能是真正绑定了 bindtap 的 view.item\r\n\r\n下面再来看下例子：  \r\n\r\n```\r\n<view id=\"outer\" bindtap=\"handleTap1\">\r\n  outer view\r\n  <view id=\"middle\" catchtap=\"handleTap2\">\r\n    middle view\r\n    <view id=\"inner\" bindtap=\"handleTap3\">\r\n      inner view\r\n    </view>\r\n  </view>\r\n</view>\r\n```\r\n\r\n> 点击 inner view 时，handleTap3 收到的事件对象 target 和 currentTarget 都是 inner，而 handleTap2 收到的事件对象 target 就是 inner，currentTarget 就是 middle。\r\n\r\n> 由此一看，可以简单总结出来：target 是事件触发源头的地方，即事件开始的地方，可以冒泡到父节点触发父节点的绑定事件；而 currentTarget 是开发者自己绑定事件的地方，即实际的绑定事件的节点。所以，如果绑定的事件有子节点，那么 target 不会等于 currentTarget，有可能是冒泡触发的，由此可见，获取 dataset 的时候使用 currentTarget 是靠谱的。  \r\n\r\n##### 小程序的事件驱动和数据绑定模型\r\n\r\n由上面数据驱动和事件监听的处理方式可见，小程序是一套数据和事件驱动的模型，即下面的形式：  \r\n\r\n![图片](https://github.com/Will0319/ImgFile/blob/master/wechat/7.jpg?raw=true)  \r\n\r\n##### 路由 \r\n\r\n在小程序内，不能像 HTML5 中 a 标签那样，随便跳转，也不能像 location 对象中对应的属性那样随意跳转，小程序提供了对应 a 标签和 location 对象的方法：[navigator 组件](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)和 [wx 中的导航相关函数](https://developers.weixin.qq.com/miniprogram/dev/api/ui-navigate.html)。  \r\n\r\n在小程序中，路由是由路由栈来维护的，小程序的路由栈中最多维护 5 个页面，这样在 5 个页面内，小程序维护其渲染页面，可以实现快速的切换。  \r\n\r\n小程序中跳转页面可以通过下面两种方式：  \r\n\r\n1. 使用 navigator 组件：\r\n\r\n```\r\n<navigator url=\"跳转页面URL\" >跳转到新页面</navigator>\r\n```\r\n\r\n2. 使用 wx 中的导航相关函数：\r\n\r\n```\r\n<view bindtap=\"gotoUrl\">跳转页面</view>\r\n```\r\n\r\n```\r\nPage({\r\n  gotoUrl(){\r\n    let url = 'pages/another/url'\r\n    wx.navigateTo({\r\n      url\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n##### JavaScript 的限制和增强\r\n\r\n微信内的 JavaScript 相对于浏览器中的有限制也有增强，增强的部分是基于小程序 Native 端能力做的增强，比如增强的文件操作类（相册、录音等）；除了增强，跟 HTML5 浏览器环境最大的不同是限制部分。  \r\n\r\n小程序的执行环境是没有浏览器了，所以浏览器环境特有的 window 对象、BOM 和 DOM 等相关 API 都存在缺失（有对应的补充 API），小程序的执行环境是类似于 Node.js 的一种执行环境。因为没有浏览器环境，所以跟浏览器相关的操作如 cookie、Ajax 请求（XMLHttpRequest）、DOM 选择器、DOM 事件、路由 history、缓存、设备信息、位置等都不存在，与之相对应的是小程序的私有 API，比如我们在小程序中不能使用 XMLHttpRequest，但是可以使用功能更加强大的 wx.request 方法。\r\n\r\n#### 小程序布局相关知识\r\n\r\n******\r\n\r\n##### rpx\r\n\r\n小程序 WXSS 中使用了 rpx 这个长度单位，可以用于表示元素的宽高和边距、字体的大小等。对于习惯使用 px 或者 rem 来做页面的前端来说，这可能让人有点迷糊。rpx 是以小程序容器宽度（等于设备宽度）恒等于 750rpx 来做定义的。对于 iPhone 6 来说，因为 dpr 为 2，所以 iPhone 的宽度为 375px，这样在 iPhone 6 上使用 rpx 的话，换算关系为 2rpx=1px。根据这样的关系类推，得到官方给的表格：  \r\n\r\n设备 | rpx换算 px (屏幕宽度/750) | px 换算 rpx (750/屏幕宽度)\r\n------------ | ------------- | ------------\r\niPhone 5 | 1rpx = 0.42px  | 1px = 2.34rpx\r\niPhone 6 | 1rpx = 0.5px  | 1px = 2rpx\r\niPhone 6 Plus | 1rpx = 0.552px  | 1px = 1.81rpx  \r\n\r\n看起来很麻烦，但是只需要按照官方建议，让设计师按照 iPhone 6 的视觉稿标准出图即可，即宽度为 750px，按照 750px 出图，那么我们写页面时直接使用测量的尺寸来设置 rpx 就行了。  \r\n\r\n关于 flex 布局相关知识，可以参考阮一峰的[ flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)和[实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)。\r\n\r\n#### 总结\r\n\r\n******\r\n\r\n更多微信小程序的基础知识可以参考官方文档：[简易教程](https://developers.weixin.qq.com/miniprogram/dev/index.html)、[框架](https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html)、[组件](https://developers.weixin.qq.com/miniprogram/dev/component/)、[API](https://developers.weixin.qq.com/miniprogram/dev/api/)。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/18",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/18/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/18/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/18/events",
            "html_url": "https://github.com/Will0319/blog/issues/18",
            "id": 368020395,
            "node_id": "MDU6SXNzdWUzNjgwMjAzOTU=",
            "number": 18,
            "title": "ES5 常用Array方法整理",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-10-09T02:48:24Z",
            "updated_at": "2018-12-19T07:29:31Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 前言\r\n数组应该是最常操作的一个数据类型了，在此整理一下操作Array的方法。\r\n\r\n### 方法录目\r\n\r\n1. <a href=\"#forEach\">forEach</a>\r\n2. <a href=\"#map\">map</a>\r\n3. <a href=\"#filter\">filter</a>\r\n4. <a href=\"#some\">some</a>\r\n5. <a href=\"#every\">every</a>\r\n6. <a href=\"#reduce\">reduce</a>\r\n7. <a href=\"#reduceRight\">reduceRight</a>\r\n8. <a href=\"#indexOf\">indexOf</a>\r\n9. <a href=\"#lastIndexOf\">lastIndexOf </a>\r\n10. <a href=\"#findIndex\">find (es6新增)</a>\r\n11. <a href=\"#findIndex\">findIndex (es6新增)</a>\r\n\r\n### <span id=\"forEach\">forEach</span>\r\nforEach 是Array中基本的一个遍历方法。\r\n\r\n```js\r\nconst arr = [1,2,3]\r\narr.forEach((item, index, array) => {\r\n    console.log(item, index, array)\r\n})\r\n\r\n// output\r\n1 0 [1,2,3]\r\n2 1 [1,2,3]\r\n3 2 [1,2,3]\r\n```\r\n\r\nforEach 方法中到callback有三个参数:\r\n* 数组当前项\r\n* 对应数组到索引\r\n* 数组本身\r\n\r\nforEach 接受一个必须到回调函数参数，还可以接受一个可选到上下文参数(改变回调函数里面到this指向)。如果没传入第二参数，则指向window，严格模式为undefined\r\n\r\n比如:\r\n```js\r\nconst arr = [1,2,3]\r\nconst obj = {name: angela}\r\n\r\narr.forEach((item, index, array) => {\r\n    console.log(item, index, array, this)\r\n}, obj)\r\n\r\n//output\r\n1 0 [1, 2, 3] {name: 'angela'}\r\n2 1 [1, 2, 3] {name: 'angela'}\r\n3 2 [1, 2, 3] {name: 'angela'}\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n```js\r\nif (typeof Array.prototype.forEach != 'function') {\r\n    Array.prototype.forEach = function(fn, context) {\r\n        for (let k = 0, length = this.length; k < length; k++) {\r\n            if (typeof fn === 'function' && Object.prototype.hasOwnProperty.call(this, k)) {\r\n                fn.call(context, this[k], k, this)\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### <span id=\"map\">map</span>\r\nmap方法是将原来对数组按照一定对规则映射出一个新的数组再返回。\r\n\r\n```js\r\n// callback参数\r\n[].map((value, index, array) => {\r\n    // ...\r\n})\r\n```\r\n\r\n数值求平方例子:\r\n\r\n```js\r\nconst data = [1,2,3]\r\nconst array = data.map(item => {\r\n    return item * item\r\n})\r\nconsole.log(array)\r\n\r\n//output\r\n[1, 4, 9]\r\n```\r\n\r\n如果callback没有return 则会输出undefiend\r\n\r\n```js\r\nconst data = [1,2,3]\r\nconst array = data.map(item => {\r\n    item * item\r\n})\r\nconsole.log(array)\r\n\r\n//output\r\n[undefiend, undefiend, undefiend]\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n```js\r\nif (typeof Array.prototype.map != 'function') {\r\n    Array.prototype.map = function(fn, context) {\r\n        let arr = []\r\n        if (typeof fn === 'function') {\r\n            for (let k = 0, length = this.length; k < lenght; k++) {\r\n                arr.push(fn.call(context, this.[k], k, this))\r\n            }\r\n        }\r\n        return arr\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n### <span id=\"filter\">filter</span>\r\nfilter 相当于过滤后返回新的数组。(true则通过，false不通过)\r\n\r\n```js\r\nconst arr = [1, 2, 3]\r\n\r\nlet arr1 = arr.filter((item, index, array) => {\r\n    return item\r\n})\r\n\r\n//output\r\n[1, 2, 3]\r\n\r\n\r\nlet arr2 = arr.filter((item, index, array) => {\r\n    return item>=2\r\n})\r\n\r\n//output\r\n[2, 3]\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n\r\n```js\r\nif (typeof Array.prototype.filter != 'function') {\r\n    Array.prototype.filter = function(fn, context) {\r\n        let arr = []\r\n        if (typeof fn === 'function') {\r\n            for (let k = 0, length = this.length; k < length; k++) {\r\n                fn.call(context, this[k], k, this) && arr.push(this[k])\r\n            }\r\n        }\r\n        return arr\r\n    }\r\n}\r\n```\r\n\r\n### some\r\nsome方法只要数组中的某个值，符合就true，反之false。\r\n\r\n```js\r\nfunction big(item, index, array) {\r\n    return item >= 4\r\n}\r\n\r\nconst count = [1, 2, 3]\r\nconst count2 = [1, 2, 3, 4]\r\ncount.some(big)  // output false\r\ncount2.some(big)  // output true\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n\r\n```js\r\nif (typeof Array.prototype.some != 'function') {\r\n    Array.prototype.some = function(fn, context) {\r\n        let passed = false\r\n        if (typeof fn === 'function') {\r\n            for (let k = 0, length = this.length; k < length; k++) {\r\n                if (passed === true) break\r\n                passed = !!fn.call(context, this[k], k, this)\r\n            }\r\n        }\r\n        return passed\r\n    }\r\n}\r\n```\r\n\r\n### <span id=\"every\">every</span>\r\nevery和some类似,但是是所有的值都符合才true，否则为false\r\n\r\n\r\n```js\r\nfunction big(item, index, array) {\r\n    return item >= 3\r\n}\r\n\r\nconst count = [2, 3, 4].every(big)  // output false\r\nconst count2 = [3, 4, 5].every(big) // output true\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n\r\n```js\r\nif (typeof Array.prototype.every != 'function') {\r\n    Array.prototype.every = function(fn, context) {\r\n        let pased = true\r\n        if (typeof fn === 'function') {\r\n            for (let k = 0, length = this.length; k < length; k++) {\r\n                if (passed === true) break\r\n                passed = !!fn.call(context, this[k], k, this)\r\n            }\r\n        }\r\n        return passed\r\n    }\r\n}\r\n```\r\n\r\n\r\n### <span id=\"reduce\">reduce</span>\r\nreduce 中文有 '减少'， '约减'的意思\r\n\r\n```js\r\narray.reduce(callback[, initialValue])\r\n```\r\n\r\ncallback函数接受4个参数 (initialValue 参数可选 标示初始值)\r\n* 之前值 previous\r\n* 当前值 current\r\n* 索引值 index\r\n* 数组本身 array\r\n\r\n```js\r\nconst sum = [1, 2, 3, 4].reduce((previous, current, index, array) => {\r\n    return previous + current\r\n})\r\nconsole.log(sum)\r\n\r\n// output\r\n// 10\r\n```\r\n\r\n解析:\r\n1. initialValue不存在，所以pervious等于数组的第一个元素\r\n2. current 在第一次调用的时候就是2\r\n\r\n```js\r\n// 初始设置\r\nprevious = initialValue = 1, current = 2\r\n\r\n// 第一次迭代\r\nprevious = (1 + 2) = 3, current = 3\r\n\r\n// 第二次迭代\r\nprevious = (3 + 3) = 6, current = 4\r\n\r\n// 第三次迭代\r\nprevious = (6 + 4) = 10, current = undefiend (退出)\r\n```\r\n\r\n例子: 数组扁平化～\r\n\r\n```js\r\nconst matrix = [[1,2],[3,4],[5,6]]\r\n\r\nconst flatten = matrix.reduce((pre, cur) => {\r\n    return pre.concat(cur)\r\n})\r\n\r\nconsole.log(flatten)\r\n\r\n// output\r\n// [1,2,3,4,5,6]\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n\r\n```js\r\nif (typeof Array.prototype.reduce != 'function') {\r\n    Array.prototype.reduce = function(callback, initialValue) {\r\n        let previous = initialValue, k = 0, length = this.length\r\n        if (typeof initialValue === 'undefiend') {\r\n            previous = this[0]\r\n            k = 1\r\n        }\r\n        if (typeof callback === 'function') {\r\n            for (k; k< length; k++) {\r\n                this.hasOwnProperty(k) && (previous = callback(previous, this[k], k, this))\r\n            }\r\n        }\r\n        return previous\r\n    }\r\n}\r\n```\r\n\r\n### <span id=\"reduceRight\">reduceRight</span>\r\nreduceRight 跟 reduce 类似， 只是reduceRight 是从数组的末尾开始实现的。\r\n\r\n### <span id=\"indexOf\">indexOf</span>\r\nindexOf说白了就是找那个元素在不在数组里面，第几个是不是它\r\n\r\n```js\r\narray.indexOf(searchElement, fromIndex)\r\n```\r\n\r\n返回整数索引值，如果没有(严格匹配)，返回-1, fromIndex参数可选，如果没有或者格式不对,使用默认值0\r\n\r\n例子:\r\n\r\n```js\r\nconst data = [2, 5, 7, 3, 5]\r\n\r\nconsole.log(data.indexOf(1))\r\n// -1\r\n\r\nconsole.log(data.indexOf(2))\r\n// 0\r\n\r\nconsole.log(data.indexOf(5))\r\n// 1\r\n\r\nconsole.log(data.indexOf(5, 2))\r\n// 4\r\n```\r\n\r\n对IE6-IE8低版本进行仿真扩展:\r\n\r\n```js\r\nif (typeof Array.prototype.indexOf != 'function') {\r\n    Array.prototype.indexOf = function(searchElement, fromIndex) {\r\n        let index = -1\r\n        fromIndex = fromIndex * 1 || 0\r\n\r\n        for (let k = 0, length = this.length; k < length; k++) {\r\n            if (k >= fromIndex && this[k] === searchElement) {\r\n                index = k\r\n                break\r\n            }\r\n        }\r\n        return index\r\n    }\r\n}\r\n```\r\n\r\n### <span id=\"lastIndexOf\">lastIndexOf</span>\r\nlastIndexOf 方法与 indexOf 方法类似。只是从末尾开始查找，且fromIndex默认值为-1\r\n\r\n```js\r\narray.lastIndexOf(searchElement, fromIndex)\r\n```\r\n\r\n### <span id='findIndex'>find / findIndex<span>\r\n\r\nfind 方法把所有的数组成员执行回调函数，直到找到一个为true的时候返回该成员。否则返回undefiend\r\n\r\n```js\r\nconst value = [1, 5, 10 ,15].find((el, index, array) => {\r\n    return el > 9\r\n})\r\n\r\nconsole.log(value) // 10\r\n\r\nconst value2 = [1, 5, 10 ,15].find((el, index, array) => {\r\n    return el > 20\r\n})\r\n\r\nconsole.log(value2) // undefiend\r\n```\r\n\r\n\r\nfindIndex 与find是类似的，只不过它返回的是索引，如果都不符合，那么返回-1\r\n\r\n```js\r\nconst value = [1, 5, 10 ,15].findIndex((el, index, array) => {\r\n    return el > 9\r\n})\r\n\r\nconsole.log(value) // 2\r\n\r\nconst value2 = [1, 5, 10 ,15].find((el, index, array) => {\r\n    return el > 20\r\n})\r\n\r\nconsole.log(value2) // -1\r\n```\r\n\r\n对不支持 find/findIndex 的浏览器进行仿真扩展:\r\n\r\n```js\r\nArray.prototype.find = Array.prototype.find || function(fn, context) {\r\n    if (typeof fn === 'function') {\r\n        for (let k = 0, length = this.length; k < length; k++) {\r\n            if (fn.call(context, this[k], k, this)) {\r\n                return this[k]\r\n            }\r\n        }\r\n    }\r\n    return undefiend\r\n}\r\n\r\n\r\nArray.prototype.findIndex = Array.prototype.findIndex || function(fn, context) {\r\n    if (typeof fn === 'function') {\r\n        for (let k = 0, length = this.length; k < length; k++) {\r\n            if (fn.call(context, this[k], k, this)) {\r\n                return k\r\n            }\r\n        }\r\n    }\r\n    return -1\r\n}\r\n```\r\n\r\n"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/17",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/17/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/17/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/17/events",
            "html_url": "https://github.com/Will0319/blog/issues/17",
            "id": 368013631,
            "node_id": "MDU6SXNzdWUzNjgwMTM2MzE=",
            "number": 17,
            "title": "ThinkPHP5 路由总结",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1072821712,
                    "node_id": "MDU6TGFiZWwxMDcyODIxNzEy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/PHP",
                    "name": "PHP",
                    "color": "a185fc",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-10-09T02:09:30Z",
            "updated_at": "2018-10-09T02:27:40Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n在这之前使用PHP写服务端已经是快一年前的事情了，那时候还是用的TP3来写的代码，最近在自己开发点小程序所以重新拾起PHP，所以呢，直接开搞最新的TP5，并且看了几天的文档，不得不说TP5和TP3差别还是很大的，在博客记录总结一下吧。首先是几个写法多变的如路由，参数，数据库操作吧。\r\n#### 路由模式\r\ntp5的路由模式有三种：  \r\n\r\n一、普通模式（PATH_INFO）  \r\n\r\n关闭路由，完全使用默认的`PATH_INFO`方式URL：\r\n\r\n```\r\n'url_route_on'  =>  false,\r\n```\r\n\r\n路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO 模式访问URL：\r\n\r\n```\r\nhttp://serverName/index.php/module/controller/action/param/value/...\r\n```\r\n\r\n二、混合模式  \r\n\r\n开启路由，并使用路由定义+默认PATH_INFO方式的混合：\r\n\r\n```\r\n'url_route_on'  =>  true,\r\n'url_route_must'=>  false,\r\n```\r\n\r\n该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其它的仍然按照第一种普通模式的PATH_INFO模式访问URL。\r\n\r\n三、强制模式(只能使用路由)  \r\n\r\n依照目前开发的`resful api`接口，选择强制模式。  \r\n\r\n开启路由，并设置必须定义路由才能访问：  \r\n\r\n```\r\n'url_route_on'  \t\t=>  true,\r\n'url_route_must'\t\t=>  true,\r\n```\r\n\r\n这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。  \r\n\r\n首页的路由规则采用/定义即可，例如下面把网站首页路由输出Hello,world!  \r\n\r\n```\r\nRoute::get('/',function(){\r\n    return 'Hello,world!';\r\n});\r\n```\r\n\r\n#### 注册路由\r\n\r\n我偏向于动态注册路由，我认为官方示例的写法上代码可读性不是太高。而动态路由注册的话首先是结构清晰，代码阅读性高，第二就是在写法上更加灵活多变。具体写法如下：\r\n\r\n\r\n> Route::rule('路由表达式','路由地址','请求类型','路由参数（数组）','变量规则（数组）');\r\n\r\n例如注册如下路由规则：\r\n\r\n```\r\nuse think\\Route;\r\n// 注册路由到index模块的News控制器的read操作\r\nRoute::rule('new/:id','index/News/read');\r\n```\r\n\r\n我们访问：\r\n```\r\nhttp://serverName/new/5\r\n```\r\n\r\n>ThinkPHP5.0的路由规则定义是从根目录开始，而不是基于模块名的。\r\n\r\n会自动路由到：\r\n\r\n```\r\nhttp://serverName/index/news/read/id/5\r\n```\r\n\r\n并且原来的访问地址会自动失效。  \r\n\r\n路由表达式（第一个参数）支持定义命名标识，例如：  \r\n\r\n```\r\n// 定义new路由命名标识\r\nRoute::rule(['new','new/:id'],'index/News/read');\r\n```\r\n\r\n>注意，路由命名标识必须唯一，定义后可以用于URL的快速生成。\r\n\r\n可以在rule方法中指定请求类型，不指定的话默认为任何请求类型，例如：  \r\n\r\n```\r\nRoute::rule('new/:id','News/update','POST');\r\n```\r\n\r\n表示定义的路由规则在POST请求下才有效。  \r\n\r\n请求类型包括：`GET`,`POST`,`PUT`,`DELETE`,`*`\r\n\r\n>注意：请求类型参数必须大写。\r\n\r\n系统提供了为不同的请求类型定义路由规则的简化方法，例如：  \r\n\r\n```\r\nRoute::get('new/:id','News/read'); // 定义GET请求路由规则\r\nRoute::post('new/:id','News/update'); // 定义POST请求路由规则\r\nRoute::put('new/:id','News/update'); // 定义PUT请求路由规则\r\nRoute::delete('new/:id','News/delete'); // 定义DELETE请求路由规则\r\nRoute::any('new/:id','News/read'); // 所有请求都支持的路由规则\r\n```\r\n\r\n如果要定义get和post请求支持的路由规则，也可以用：\r\n\r\n```\r\nRoute::rule('new/:id','News/read','GET|POST');\r\n```\r\n\r\n我们也可以批量注册路由规则，例如：\r\n\r\n```\r\nRoute::rule(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);\r\nRoute::get(['new/:id'=>'News/read','blog/:name'=>'Blog/detail']);\r\nRoute::post(['new/:id'=>'News/update','blog/:name'=>'Blog/detail']);\r\n```\r\n\r\n注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。\r\n\r\n#### 全局MISS路由\r\n\r\n如果希望在没有匹配到所有的路由规则后执行一条设定的路由，可以使用MISS路由功能，只需要在路由配置文件中定义：\r\n\r\n```\r\nRoute::miss('public/miss');\r\n```\r\n\r\n当没有匹配到所有的路由规则后，会路由到 public/miss路由地址。\r\n\r\n#### 结束总结\r\n\r\n基本内容大概就是这样，在做项目的时候再来慢慢填这里的坑吧…"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/16",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/16/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/16/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/16/events",
            "html_url": "https://github.com/Will0319/blog/issues/16",
            "id": 364963606,
            "node_id": "MDU6SXNzdWUzNjQ5NjM2MDY=",
            "number": 16,
            "title": "MAMP配置虚拟域名",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1072821712,
                    "node_id": "MDU6TGFiZWwxMDcyODIxNzEy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/PHP",
                    "name": "PHP",
                    "color": "a185fc",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-09-28T16:43:46Z",
            "updated_at": "2018-09-28T17:19:02Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n\r\n在写PHP的时候调试接口的时候前面一大串域名看的头疼，于是看了一下如何在Mac的MAMP中设置虚拟域名，这里记录一下。\r\n\r\n#### 方法\r\n先进入apache的配置文件`httpd.conf`，路径是/Applications/MAMP/conf/apache/httpd.conf，用文本编辑器打开，command+f查找一下‘vhosts’关键字,来到了这一行\r\n\r\n```\r\n#Include /Applications/MAMP/conf/apache/extra/httpd-vhosts.conf\r\n```\r\n\r\n把前面的#号去掉，表示这句话生效，这句话的意思就是使虚拟地址的配置文件生效。  \r\n保存后，用文本编辑器打开 /Applications/MAMP/conf/apache/extra/httpd-vhosts.conf，加入需要配置的虚拟地址,大概是这样的：  \r\n这里注意不要照着MAMP里面httpd-vhosts.conf的演示代码写，我试过那个不起作用，用下面的可以。  \r\n\r\n```\r\n<VirtualHost *:80>\r\n    DocumentRoot \"/Applications/MAMP/htdocs/tp5/public\"\r\n    ServerName tp.cn\r\n    ServerAlias tp.cn\r\n    <Directory \"/Applications/MAMP/htdocs/tp5/public\">\r\n        Options Indexes FollowSymLinks   \r\n        AllowOverride All\r\n        Order deny,allow\r\n        Allow from all\r\n    </Directory>\r\n</VirtualHost>\r\n```\r\n\r\n其中`DocumentRoot`就是你的网站文件目录，`ServerName`是你希望配置的虚拟域名，`ServerAlias`也是一个别名，下面的`Directory`标签是一些配置，这些参数我也还在学习中…  \r\n\r\n例如第一个Options Indexes FollowSymLinks的意思是如果有index就显示index文件，如果没有就显示目录结构。  \r\n\r\n保存后，来到host配置文件，/etc/hosts，可以进入finder，shift+command+G,输入/etc,回车后找到`hosts`文件，用编辑器打开，也可以直接在终端输入sudo vi /etc/hosts，然后添加一行解析的语句  \r\n\r\n```\r\n127.0.0.1 tp.cn\r\n```\r\n\r\n保存以后，重启一下apache，在浏览器输入tp.cn，就是你刚才设置的虚拟域名，到这就成功了。  \r\n如果是mac自带的apache,httpd.conf 配置文件在/etc/apache2/httpd.conf 这儿，httpd-vhosts.conf文件在/etc/apache2/extra//etc/vhosts.conf这儿，hosts还是原来的位置。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/15",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/15/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/15/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/15/events",
            "html_url": "https://github.com/Will0319/blog/issues/15",
            "id": 363879049,
            "node_id": "MDU6SXNzdWUzNjM4NzkwNDk=",
            "number": 15,
            "title": "React高阶组件",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-09-26T06:41:22Z",
            "updated_at": "2018-09-26T09:26:40Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "\r\n#### 前言\r\n有时候人们很喜欢造一些名字很吓人的名词，让人一听这个名词就觉得自己不可能学会，从而让人望而却步。但是其实这些名词背后所代表的东西其实很简单。 \r\n\r\n#### 高阶组件定义\r\n> a higher-order component is a function that takes a component and returns a new component.\r\n\r\n翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\r\n> \r\n理解了吗？看了定义似懂非懂？继续往下看。 \r\n#### 函数模拟高阶组件\r\n我们通过普通函数来理解什么是高阶组件哦~\r\n\r\n1. 最普通的方法，一个`welcome`，一个`goodbye`。两个函数先从`localStorage`读取了`username`，然后对`username`做了一些处理。\r\n\r\n```js\r\nfunction welcome() {\r\n    let username = localStorage.getItem('username');\r\n    console.log('welcome ' + username);\r\n}\r\n\r\nfunction goodbey() {\r\n    let username = localStorage.getItem('username');\r\n    console.log('goodbey ' + username);\r\n}\r\n\r\nwelcome();\r\ngoodbey();\r\n```\r\n\r\n2. 我们发现两个函数有一句代码是一样的，这叫冗余唉。不好不好~（你可以把那一句代码理解成平时的一大堆代码）\r\n我们要写一个中间函数，读取`username`,他来负责把`username`传递给两个函数。\r\n\r\n```js\r\nfunction welcome(username) {\r\n    console.log('welcome ' + username);\r\n}\r\n\r\nfunction goodbey(username) {\r\n    console.log('goodbey ' + username);\r\n}\r\n\r\nfunction wrapWithUsername(wrappedFunc) {\r\n    let newFunc = () => {\r\n        let username = localStorage.getItem('username');\r\n        wrappedFunc(username);\r\n    };\r\n    return newFunc;\r\n}\r\n\r\nwelcome = wrapWithUsername(welcome);\r\ngoodbey = wrapWithUsername(goodbey);\r\n\r\nwelcome();\r\ngoodbey();\r\n```\r\n\r\n好了，我们里面的`wrapWithUsername`函数就是一个“高阶函数”。\r\n他做了什么？他帮我们处理了`username`，传递给目标函数。我们调用最终的函数`welcome`的时候，根本不用关心`username`是怎么来的。\r\n\r\n我们增加个用户`study`函数。\r\n\r\n```js\r\nfunction study(username){\r\n    console.log(username+' study');\r\n}\r\nstudy = wrapWithUsername(study);\r\n\r\nstudy();\r\n```\r\n\r\n这里你是不是理解了为什么说`wrapWithUsername`是高阶函数？我们只需要知道，用`wrapWithUsername`包装我们的`study`函数后，`study`函数第一个参数是`username`。\r\n\r\n我们写平时写代码的时候，不用关心`wrapWithUsername`内部是如何实现的。\r\n\r\n#### 高阶组件\r\n**高阶组件就是一个没有副作用的纯函数。**\r\n\r\n我们把上一节的函数统统改成`react`组件。\r\n\r\n1. 最普通的组件哦。\r\n\r\n`welcome`函数转为`react`组件。\r\n\r\n```js\r\nimport React, {Component} from 'react'\r\n\r\nclass Welcome extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            username: ''\r\n        }\r\n    }\r\n\r\n    componentWillMount() {\r\n        let username = localStorage.getItem('username');\r\n        this.setState({\r\n            username: username\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>welcome {this.state.username}</div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Welcome;\r\n```\r\n\r\n`goodbey`函数转为`react`组件。\r\n\r\n```js\r\nimport React, {Component} from 'react'\r\n\r\nclass Goodbye extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            username: ''\r\n        }\r\n    }\r\n\r\n    componentWillMount() {\r\n        let username = localStorage.getItem('username');\r\n        this.setState({\r\n            username: username\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>goodbye {this.state.username}</div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Goodbye;\r\n```\r\n\r\n1. 现在你是不是更能看到问题所在了？两个组件大部分代码都是重复的唉。\r\n\r\n按照上一节`wrapWithUsername`函数的思路，我们来写一个高阶组件(高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件)。\r\n\r\n```js\r\nimport React, {Component} from 'react'\r\n\r\nexport default (WrappedComponent) => {\r\n    class NewComponent extends Component {\r\n        constructor() {\r\n            super();\r\n            this.state = {\r\n                username: ''\r\n            }\r\n        }\r\n\r\n        componentWillMount() {\r\n            let username = localStorage.getItem('username');\r\n            this.setState({\r\n                username: username\r\n            })\r\n        }\r\n\r\n        render() {\r\n            return <WrappedComponent username={this.state.username}/>\r\n        }\r\n    }\r\n\r\n    return NewComponent\r\n}\r\n```\r\n\r\n这样我们就能简化`Welcome`组件和`Goodbye`组件。\r\n\r\n```js\r\nimport React, {Component} from 'react';\r\nimport wrapWithUsername from 'wrapWithUsername';\r\n\r\nclass Welcome extends Component {\r\n\r\n    render() {\r\n        return (\r\n            <div>welcome {this.props.username}</div>\r\n        )\r\n    }\r\n}\r\n\r\nWelcome = wrapWithUsername(Welcome);\r\n\r\nexport default Welcome;\r\n```\r\n\r\n```js\r\nimport React, {Component} from 'react';\r\nimport wrapWithUsername from 'wrapWithUsername';\r\n\r\nclass Goodbye extends Component {\r\n\r\n    render() {\r\n        return (\r\n            <div>goodbye {this.props.username}</div>\r\n        )\r\n    }\r\n}\r\n\r\nGoodbye = wrapWithUsername(Goodbye);\r\n\r\nexport default Goodbye;\r\n```\r\n\r\n看到没有，高阶组件就是把`username`通过`props`传递给目标组件了。目标组件只管从`props`里面拿来用就好了。\r\n\r\n到这里位置，高阶组件就讲完了。你再返回去理解下定义，是不是豁然开朗~\r\n\r\n你现在理解`react-redux`的`connect`函数~\r\n\r\n把`redux`的`state`和`action`创建函数，通过`props`注入给了`Component`。\r\n你在目标组件`Component`里面可以直接用`this.props`去调用`redux state`和`action`创建函数了。\r\n\r\n```js\r\nConnectedComment = connect(mapStateToProps, mapDispatchToProps)(Component);\r\n```\r\n\r\n相当于这样\r\n\r\n```js\r\n// connect是一个返回函数的函数（就是个高阶函数）\r\nconst enhance = connect(mapStateToProps, mapDispatchToProps);\r\n// 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store\r\n// 关联起来的新组件\r\nconst ConnectedComment = enhance(Component);\r\n```\r\n\r\n`antd`的Form也是一样的\r\n\r\n```js\r\nconst WrappedNormalLoginForm = Form.create()(NormalLoginForm);\r\n```\r\n\r\n参考地址：\r\n\r\n1. http://huziketang.com/books/react/lesson28\r\n2. https://react.bootcss.com/react/docs/higher-order-components.html\r\n\r\n"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/14",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/14/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/14/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/14/events",
            "html_url": "https://github.com/Will0319/blog/issues/14",
            "id": 359101246,
            "node_id": "MDU6SXNzdWUzNTkxMDEyNDY=",
            "number": 14,
            "title": "轻量级进度条Nprogress",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-09-11T15:30:43Z",
            "updated_at": "2018-09-11T15:36:59Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n在浏览Antd或者别人博客的时候加载时可以看到顶部有加载条，感觉挺好看的，但是不知道怎么来的，今天花时间好好找了找。终于找到了一款好看又使用简单方便的轻量级进度条插件：NProgress。  \r\n下面放展示图：  \r\n ![NProgress效果示例图](https://github.com/Will0319/ImgFile/blob/master/nprogress.gif?raw=true)    \r\n\r\nGit: https://github.com/rstacruz/nprogress  \r\n******\r\n#### 安装\r\n```\r\nyarn add nprogress\r\n<!--Or-->\r\ncnpm install nprogress\r\n```\r\n#### 基本用法\r\n只需要调用start() 和 done()来控制进度条\r\n\r\n```\r\nNProgress.start();\r\nNProgress.done();\r\n```\r\n#### 高级用法\r\n**百分比**：通过设置progress的百分比，调用 .set(n)来控制进度，其中n的取值范围为0-1。\r\n\r\n```\r\nNProgress.set(0.0);     // Sorta same as .start()\r\nNProgress.set(0.4);\r\nNProgress.set(1.0);     // Sorta same as .done()\r\n```\r\n**递增**：要让进度条增加，只要调用 .inc()。这会产生一个随机增量，但不会让进度条达到100%。此函数适用于图片加载或其他类似的文件加载。\r\n\r\n```\r\nNProgress.inc();\r\n```\r\n**强制完成**：通过传递 true 参数给done()，使进度条满格，即使它没有被显示。\r\n\r\n```\r\nNProgress.done(true);\r\n\r\n```\r\n#### 配置\r\n**minimum**：设置最低百分比\r\n\r\n```\r\nNProgress.configure({ minimum: 0.1 });\r\n```\r\n**template**：改变进度条的HTML结构。为保证进度条能正常工作，需要元素拥有role=’bar’属性。\r\n\r\n```\r\nNProgress.configure({\r\n  template: \"<div class='....'>...</div>\"\r\n});\r\n```\r\n**ease**：调整动画设置，ease可传递CSS3缓冲动画字符串（如ease、linear、ease-in、ease-out、ease-in-out、cubic-bezier）。speed为动画速度（单位ms）。\r\n\r\n```\r\nNProgress.configure({ ease: 'ease', speed: 500 });\r\n```\r\n\r\n#### 在异步加载中使用插件\r\n思路是在组件js还未加载完全时插件start方法，JS加载结束后调用done方法。我就简单暴力直接贴一个异步加载的代码吧。\r\n\r\n```\r\nimport React, { Component } from \"react\";\r\nimport {Spin} from 'antd';\r\nimport NProgress from 'nprogress';\r\nimport 'nprogress/nprogress.css';\r\n\r\nexport default function asyncComponent(importComponent) {\r\n    class AsyncComponent extends Component {\r\n        constructor(props) {\r\n            super(props);\r\n\r\n            this.state = {\r\n                component: null\r\n            };\r\n            NProgress.start();\r\n            // console.log('start')\r\n        }\r\n        \r\n        async componentDidMount() {\r\n            const { default: component } = await importComponent();\r\n\r\n            this.setState({\r\n                component: component\r\n            });\r\n        }\r\n\r\n        render() {\r\n            const Component = this.state.component;\r\n            if (Component){\r\n                NProgress.done();\r\n                // console.log('done')\r\n            }\r\n            return Component ? <Component {...this.props} /> : <div>加载中...</div>\r\n        }\r\n    }\r\n\r\n    return AsyncComponent;\r\n}\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/13",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/13/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/13/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/13/events",
            "html_url": "https://github.com/Will0319/blog/issues/13",
            "id": 355648871,
            "node_id": "MDU6SXNzdWUzNTU2NDg4NzE=",
            "number": 13,
            "title": "正则匹配",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1166442342,
                    "node_id": "MDU6TGFiZWwxMTY2NDQyMzQy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E6%AD%A3%E5%88%99",
                    "name": "正则",
                    "color": "29dee8",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-30T15:53:39Z",
            "updated_at": "2018-12-19T07:26:25Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 创建正则表达式\r\n```js\r\nlet regex = new RegExp(\"a\")\r\n\r\nlet regex = new RegExp(\"^[a-zA-Z]\", \"g\")\r\n\r\nlet regex = new RegExp(/^[a-zA-Z]/, 'gi')\r\n```\r\n\r\n\r\n### 正则表达式参数\r\n\r\n* g 全局匹配（找到所有的，而不是找到第一个后就停了）\r\n* i 匹配全部大小写\r\n* m 多行  开始和结束（^和$）分别匹配每一行\r\n* s 和 m 相反，单行匹配\r\n\r\n\r\n### 正则中常用方法，字符串中与正则相关的方法\r\n\r\n1. test() 方法检索字符串中的值是否与正则匹配，返回boolean  \r\n\r\n```js\r\n// 检索\"ab\"是否在 \"abcd\" 里面\r\n\r\n/^[a-z]/.test(\"ab\")\r\n```\r\n\r\n2. exec() 方法检索指定值，如果匹配返回结果数组，反之返回 null\r\n\r\n```js\r\n// 检索 /abc/是否在 \"defaabc\" 有匹配到\r\n\r\n/abc/.exec(\"defaabc\") // arr \r\n\r\n// 检索 /qqq/是否在 \"defaabc\" 有匹配到\r\n\r\n/qqq/.exec(\"defaabc\") // null\r\n```\r\n\r\n3. compile() 方法用于改变正则匹配内容\r\n\r\n```js\r\n// /abc/改成/def/\r\n\r\n/abc/.compile('def')\r\n```\r\n\r\n\r\n4. split() 将字符串分割成数组\r\n\r\n```js\r\n// 将 \"abcd\" 以/b/分割\r\n\r\n\"abcd\".split(/b/)\r\n```\r\n\r\n5. replace() 在字符串中替换\r\n\r\n```js\r\n// 用 /\\d\\d\\d/去匹配字符串 \"12345abcde\" 将匹配内容换成 * ,并返回\r\n\r\n\"12345abcde\".replace(/\\d\\d\\d/g, '*')\r\n\r\n// 去掉字符串的引号，换成空\r\n\r\n\"12345abcde\".replace(/\"/g, '')\r\n\r\n// 去掉所有空格，tab。换行，换页\r\n\r\n\" 12 345ab cd   e  \".replace(/\\s/g, '')\r\n```\r\n\r\n6. search() 匹配指定字符串，返回匹配字符串的起始位置的索引，反之返回-1\r\n\r\n```js\r\n\"abcdefg\".search(/d/g)\r\n\r\n\"abcdefg\".search(/x/g)\r\n```\r\n\r\n\r\n7. match() 在字符串中检索指定的值，找到一个或者多个\r\n\r\n```js\r\n// 返回指定索引的值\r\n\r\n\"aabbbbbccbbaab\".match(/b+/g)\r\n```\r\n\r\n\r\n### 常用正则规则\r\n\r\n1. 字符类规则\r\n\r\n ![png1](https://github.com/Will0319/ImgFile/blob/master/zhengze/1.png?raw=true)\r\n\r\n2. 范围符号匹配规则\r\n\r\n ![png2](https://github.com/Will0319/ImgFile/blob/master/zhengze/2.png?raw=true)\r\n\r\n3. 分组匹配规则\r\n\r\n ![png3](https://github.com/Will0319/ImgFile/blob/master/zhengze/3.png?raw=true)\r\n\r\n4. 重复匹配规则\r\n\r\n ![png4](https://github.com/Will0319/ImgFile/blob/master/zhengze/4.png?raw=true)\r\n\r\n### 常用正则匹配  \r\n\r\n<strong>(1) 手机号</strong>\r\n\r\n* 移动号段: 134 135 136 137 138 139 147 148 150 151 152 157 158 159 172 178 182 183 184 187 188 198\r\n* 联通号段: 130 131 132 145 146 155 156 166 171 175 176 185 186\r\n* 电信号段: 133 149 153 173 174 177 180 181 189 199\r\n* 虚拟运营商: 170\r\n\r\n<strong>匹配 13* 的手机号</strong>\r\n```js\r\n/^(1)3(\\d){9}$/.test(13131121111)\r\n```\r\n\r\n<strong>匹配 15* 的手机号</strong>\r\n\r\n```js\r\n/^(1)5[^4]{9}$/.test(15531121989)\r\n```\r\n\r\n<strong>匹配 16* 的手机号</strong>\r\n\r\n```js\r\n/^(1)66(\\d){8}$/.test(16631121989)\r\n```\r\n\r\n<strong>匹配 17* 的手机号</strong>\r\n\r\n```js\r\n/^(1)7[0-8]{1}(\\d){8}$/.test(17199121989)\r\n```\r\n\r\n<strong>匹配 18* 的手机号</strong>\r\n\r\n```js\r\n/^(1)8(\\d){9}$/.test(18131121989)\r\n```\r\n\r\n<strong>匹配 19* 的手机号</strong>\r\n\r\n```js\r\n/^(1)9[8-9](\\d){8}$/.test(19831121989)\r\n```\r\n\r\n<strong>匹配所有的手机号</strong>\r\n\r\n```js\r\n/^(1)(3(\\d){9}$)|(4[5-9]{1}(\\d){8}$)|(5[^4]{9})|(66(\\d){8})|(7[0-8]{1}(\\d){8})|(8(\\d){9}$)|(9[8-9](\\d){8}$)/.test(19931121989)\r\n```\r\n\r\n<strong>(2) 邮箱</strong>\r\n\r\n* 126规则：6~18个字符，可使用字母、数字、下划线，需以字母开头\r\n* 163规则：6~18个字符，可使用字母、数字、下划线，需以字母开头 允许手机号\r\n* qq邮箱：数字5-10个数字\r\n* 新浪邮箱规则：4-16个字符，可使用英文小写，数字，下划线，下划线不可在首位\r\n* 搜狐邮箱规则：4-16位，英文、数字、下划线，小写字母开头\r\n\r\n<strong>匹配126邮箱</strong>\r\n\r\n```js\r\n/((^([a-zA-Z])){1}(\\w){5,17})@126.com$/.test(\"AA3333333333333333@126.com\")\r\n```\r\n\r\n<strong>匹配163邮箱</strong>\r\n\r\n```js\r\n/((^([a-zA-Z])){1}(\\w){5,17}$)|(^(1)(3(\\d){9}$)|(4[5-9]{1}(\\d){8}$)|(5[^4]{9})|(66(\\d){8})|(7[0-8]{1}(\\d){8})|(8(\\d){9}$)|(9[8-9](\\d){8}$))@163.com$/.test(\"15132221989@163.com\")\r\n```\r\n\r\n<strong>匹配qq邮箱</strong>\r\n\r\n```js\r\n/(^[1-9]){5,10}@qq.com$/.test(\"115511@qq.com\")\r\n```\r\n\r\n<strong>匹配新浪邮箱</strong>\r\n\r\n```js\r\n/(^([a-z])|^(\\d)){1}(\\w){3,15}@sina.(cn)|(com)$/.test(\"223dddddddfasddw@sina.com\")\r\n```\r\n\r\n<strong>匹配搜狐邮箱</strong>\r\n\r\n```js\r\n/(^[a-z]){1}(\\w){3,15}@sohu.com$/.test(\"dddddddfw@sohu.com\")\r\n```\r\n\r\n<strong>中文</strong>\r\n\r\n```js\r\n/^[\\u4e00-\\u9fa5]$/g.test(\"我\")   \r\n```\r\n"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/12",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/12/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/12/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/12/events",
            "html_url": "https://github.com/Will0319/blog/issues/12",
            "id": 354382582,
            "node_id": "MDU6SXNzdWUzNTQzODI1ODI=",
            "number": 12,
            "title": "Redux-logger日志输出",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1036954068,
                    "node_id": "MDU6TGFiZWwxMDM2OTU0MDY4",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Redux",
                    "name": "Redux",
                    "color": "0052cc",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-27T16:14:22Z",
            "updated_at": "2018-08-29T01:25:24Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n在Redux开发中都会希望对每个Action进行一个监控，因为只要知道此时的State就能知道现在的View,可以更好的进行一个开发调试。  \r\n******\r\n#### 什么是Redux-logger\r\n先介绍一下Redux-logger吧，这是一个middleware  \r\n什么是middleware呢？引用一下官方的解释：  \r\n>middleware提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。\r\n如果官方解释还不够清晰的话我们引用一下代码吧，比如在一个Action刚发起，到生效之前，在这些过程做一些扩展。比如希望在每次的Action前后打印出一些内容，你可以这么做。\r\n\r\n```\r\nfunction mapDispatchToProps(dispatch) {\r\n  return {\r\n    changeName () {\r\n      console.log('即将开始改名……')\r\n      dispatch({\r\n        type: 'CHANGE_NAME',\r\n        name: 'Will'\r\n      })\r\n      console.log('完成改名！')\r\n    }\r\n  }\r\n}\r\n```\r\n这样是不是能够很清楚的理解了我们要做什么，但是这样是实现了我们想做的事情，但是非常的👎…  \r\n并且，这仅仅是一个Action，如果你想要让每个Action都生效，你绝对不会一个一个去写吧。但是如果使用middleware就可以轻松的搞定了。  \r\n官方推荐了一个实现相同功能的middleware:redux-logger。  \r\n下面上个图吧  \r\n![图片标题](https://github.com/Will0319/ImgFile/blob/master/Logger.png?raw=true)\r\n#### 如何使用\r\n通过上面的认识我们了解了什么是middleware和什么是redux-logger。  \r\n接下来我们看一下如何使用这个middleware吧。  \r\n\r\n* 1. 安装  \r\n\r\n```\r\nnpm i --save redux-logger\r\n//OR\r\nyarn add redux-logger --save\r\n```\r\n* 2. 简单使用  \r\n\r\n```\r\nimport { applyMiddleware, createStore } from 'redux';\r\n\r\n// Logger with default options\r\nimport logger from 'redux-logger'\r\nconst store = createStore(\r\n  reducer,\r\n  applyMiddleware(logger)\r\n)\r\n```\r\n解释一下这段代码吧，**redux-logger**提供了一个生成器**createLogger**,可以生成日志中间件**logger**。然后，将它放在**applyMiddleware**方法之中，传入**createStore**方法，就完成了一个**store.dispath()**的功能增强了。  \r\n\r\n但是在这里有两点是需要注意的：  \r\n（1）**createStore**方法可以接受整个应用的初始状态作为参数，那样的话，**applyMiddleware**就是第三个参数了。\r\n```\r\nconst store = createStore(\r\n  reducer,\r\n  initial_state,\r\n  applyMiddleware(logger)\r\n);\r\n```\r\n（2）中间件的次序有讲究。\r\n```\r\nconst store = createStore(\r\n  reducer,\r\n  applyMiddleware(thunk, promise, logger)\r\n);\r\n```\r\n上面代码中，**applyMiddleware**方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，**logger**就一定要放在最后，否则输出结果会不正确。  \r\n看到这里，有些童鞋可能对**applyMiddleware**还不太理解，这东西到底是干什么的呢？  \r\n它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。  \r\n```\r\nexport default function applyMiddleware(...middlewares) {\r\n  return (createStore) => (reducer, preloadedState, enhancer) => {\r\n    var store = createStore(reducer, preloadedState, enhancer);\r\n    var dispatch = store.dispatch;\r\n    var chain = [];\r\n\r\n    var middlewareAPI = {\r\n      getState: store.getState,\r\n      dispatch: (action) => dispatch(action)\r\n    };\r\n    chain = middlewares.map(middleware => middleware(middlewareAPI));\r\n    dispatch = compose(...chain)(store.dispatch);\r\n\r\n    return {...store, dispatch}\r\n  }\r\n}\r\n```\r\n上面代码中，所有中间件被放进了一个数组**chain**，然后嵌套执行，最后执行**store.dispatch**。可以看到，中间件内部（**middlewareAPI**）可以拿到**getState**和**dispatch**这两个方法。  \r\n\r\n* 3. redux-logger的配置  \r\n\r\n如果你想要给redux-logger一些配置的话可以这么做  \r\n```\r\nimport { applyMiddleware, createStore } from 'redux';\r\nimport { createLogger } from 'redux-logger'\r\n\r\nconst logger = createLogger({\r\n  // ...配置，例如：\r\n        diff:true, //对比\r\n        collapsed:true //收缩\r\n});\r\n\r\nconst store = createStore(\r\n  reducer,\r\n  applyMiddleware(logger)\r\n);\r\n```\r\n* 4. 仅开发环境中使用  \r\n\r\n```\r\nconst middlewares = [];\r\n\r\nif (process.env.NODE_ENV === `development`) {\r\n  const { logger } = require(`redux-logger`);\r\n\r\n  middlewares.push(logger);\r\n}\r\n\r\nconst store = compose(applyMiddleware(...middlewares))(createStore)(reducer);\r\n```\r\n我使用的脚手架是creact-react-app，默认支持的环境变量有：NODE_ENV和PUBLIC_URL  \r\n**NODE_ENV**: 该变量是自动赋值的，你不可以更改它的值，对于npm start, 它的值是develepment, npm test它的值是test, 对于npm run build, 它的值是production  \r\n**PUBLIC_URL**: 这个变量可以用于引用模块系统之外的资源路径前缀  \r\n所以可以用NODE_ENV环境变量来区分环境，解决开发上线不显示logger。\r\n这些环境变量是可以自定义的，不过需要遵照一个约定，所有自定义环境变量均以REACT_APP_开头。  \r\n这些环境变量会定义在process.env中。例如，环境变量REACT_APP_SECRET_CODE会在JS中暴露为process.env.REACT_APP_SECRECT_CODE。  \r\n如果需要自定义环境变量,代码如下：  \r\n```\r\n// 修改package.json\r\n  \"scripts\": {\r\n    \"start\": \"cross-env REACT_APP_SECRET_API=development node scripts/start.js\",\r\n    \"build\": \"node scripts/build.js\",\r\n    \"test\": \"node scripts/test.js --env=jsdom\"\r\n// 这三个是我加的 可以根据你的业务需求来\r\n    \"build-dev\": \"cross-env REACT_APP_SECRET_API=development node scripts/build.js\",\r\n    \"build-test\": \"cross-env REACT_APP_SECRET_API=test node scripts/build.js\",\r\n    \"build-pro\": \"cross-env REACT_APP_SECRET_API=production node scripts/build.js\",\r\n\r\n  },\r\n```\r\n然后我们在执行 npm run build-dev 的时候就可以拿到 REACT_APP_SECRET_API 的值为**development**  \r\n前面加**cross-env**是为了兼容不同平台,需要自行安装**npm install cross-env --save-dev**。\r\n\r\n#### 总结\r\nemmmm…  \r\n花了大半个小时总结了一下，上述基本就是Redux-logger的基本用法啦，有遇到什么问题的话可以在下面的留言哦~ 🤞🤞🤞  \r\n参考文章：  \r\n（1）阮大大—[Redux 入门教程（二）：中间件与异步操作](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html)  \r\n（2）官方MD文档：[evgenyrodionov/redux-logger](https://github.com/evgenyrodionov/redux-logger)"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/11",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/11/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/11/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/11/events",
            "html_url": "https://github.com/Will0319/blog/issues/11",
            "id": 353031957,
            "node_id": "MDU6SXNzdWUzNTMwMzE5NTc=",
            "number": 11,
            "title": "BrowserRouter食用指南",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1032228032,
                    "node_id": "MDU6TGFiZWwxMDMyMjI4MDMy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Nginx",
                    "name": "Nginx",
                    "color": "8fefa6",
                    "default": false
                },
                {
                    "id": 1032208621,
                    "node_id": "MDU6TGFiZWwxMDMyMjA4NjIx",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React-Router",
                    "name": "React-Router",
                    "color": "f2c4ab",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-22T16:30:47Z",
            "updated_at": "2018-08-24T11:20:00Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n路由肯定是一个网站基本不可或缺的，之前使用的HashRouter，但是在网站路径上带了个#让强迫症患者十分难受，今天就换成了BrowserRouter，但是遇到了一些坑在这里记录一下吧。\r\n******\r\n#### 遇到的问题\r\n在本地开发的时候，将HashRouter换成BrowserRouter的时候没什么问题，而且网站地址栏让我看的很舒服。可是服务器上就出问题了，刷新会页面空白，404。\r\n#### 分析问题\r\n当时一想404问题就是文件找不到咯，那为什么在本地开发却不会遇到问题的原因就很明白了。  \r\n首先先讲一下这两个路由有什么区别吧。  \r\n>hashHistory 使用 URL 中的 hash（#）部分去创建路由，举例来说，用户访问http://www.yx319.cn/  \r\n实际会看到的是http://www.yx319.com/#/。  \r\n\r\n>browserHistory 是使用 React-Router 的应用推荐的 history方案。它使用浏览器中的 History API 用于处理 URL，创建一个像yx319.cn/blog/1这样真实的 URL 。\r\n这两种的区别一对比，那就是因为用了browserHistory的时候服务器去请求不存在的页面自然就会是404啦。\r\n#### 解决方法\r\n通过知道问题的所在，那么就直接去服务器上更改一下配置就可以了。  \r\n我使用的是Nginx服务器，这里就介绍一下Nginx服务器配置的修改方法吧，Apache也是同理网上也有很多介绍的吧。\r\n```\r\nlocation / {\r\n   try_files $uri /index.html;\r\n}\r\n```\r\n通过以上配置修改指向index.html页面。  \r\n******\r\n以上，就可以不用看/#/这样难受的路由啦。😏"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/10",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/10/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/10/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/10/events",
            "html_url": "https://github.com/Will0319/blog/issues/10",
            "id": 353012097,
            "node_id": "MDU6SXNzdWUzNTMwMTIwOTc=",
            "number": 10,
            "title": "Gitalk评论系统",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-22T15:40:50Z",
            "updated_at": "2018-08-22T16:38:22Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n博客写完有段时间了，总感觉缺了点什么。评论功能总是不能少的吧，于是乎开始寻找第三方的评论系统。国内的几款都试了不是不怎么好用就是完全不能用阿！而且国内几个比较主流的评论系统目前都无法在Github Pages上的个人博客使用。后来寻寻觅觅找到了Gitalk，并且使用起来是相当简单，在这里推荐一下这一款评论系统。\r\n******\r\n#### 展示\r\n在这里先放上Gitalk的官方Demo来让大家欣赏一下吧  \r\n[**Demo**]戳这里->https://gitalk.github.io/  \r\n然后是放上官方的文档吧，有些人比较喜欢自己看文档不想听我碎碎念…   \r\n[**文档**]戳这里->https://github.com/gitalk/gitalk/blob/master/readme.md  \r\n#### 使用手册 ✋\r\n安装与引入\r\n```\r\n//首先是安装Gitalk\r\nnpm i --save gittalk 或者yarn add gittalk--save\r\n//在文件中引入\r\nimport 'gitalk/dist/gitalk.css'\r\nimport Gitalk from 'gitalk'\r\n```\r\n在React组件中如何使用？这里就直接po代码啦~\r\n```\r\nimport 'gitalk/dist/gitalk.css';\r\nimport Gitalk from 'gitalk';\r\nimport React from 'react';\r\nexport default class Gitalk extends React.Component {\r\n    componentDidMount(){\r\n        const gitalk = new Gitalk({\r\n            enable: true,\r\n            clientID: '你的clientID',\r\n            clientSecret: '你的clientSecret',\r\n            repo: '评论放在哪个repo',\r\n            owner: '作者',\r\n            admin: '用户',\r\n            id: 传你的issues的number,\r\n            distractionFreeMode: false\r\n        })\r\n        gitalk.render('gitalk-container')\r\n    }\r\n    render(){\r\n        return(\r\n            <div id='gitalk-container'></div>\r\n        )\r\n    }\r\n}\r\n```\r\n那么在上面配置中的clientID,clientSecret如何来的呢？  \r\n[**引导**]到此处申请->https://github.com/settings/applications/new  \r\n这里再介绍一下这个页面的几个参数分别是怎么填的吧  \r\nApplication name： 应用名称，随意填写  \r\nHomepage URL： 网站URL，对应自己博客地址  \r\nApplication description ：描述，随意填写  \r\nAuthorization callback URL： 网站回调地址，填博客地址就好  \r\n******\r\n就这样吧，巨细无比的使用说明到这里就结束了。  \r\n如果配置那一块还有什么需要的可以去看官方手册吧，手册有中文版。  \r\n按照步骤几分钟就可以给自己的博客入手一个美观，功能全面的评论系统啦！\r\n******\r\n#### 后记\r\n这个Gitalk需要重新挂载才能够去拿新的issus，所以看每个博客页的时候都需要重新加载一次。（勉强接受吧…）😔"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/9",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/9/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/9/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/9/events",
            "html_url": "https://github.com/Will0319/blog/issues/9",
            "id": 352796356,
            "node_id": "MDU6SXNzdWUzNTI3OTYzNTY=",
            "number": 9,
            "title": "手机设置字体大小导致h5页面在webview中变形的BUG",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1132311411,
                    "node_id": "MDU6TGFiZWwxMTMyMzExNDEx",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Css",
                    "name": "Css",
                    "color": "f78011",
                    "default": false
                },
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-22T04:07:41Z",
            "updated_at": "2018-11-19T03:48:04Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n\r\n最近做了一个H5页面，在各种手机浏览器中打开都没有问题。并且采用了rem单位进行布局，通过JS来动态计算网页的视窗宽度，动态设置了html的font-size。当一切感觉完美，交给APP开发，一嵌套到WebView中的时候问题就出现了。页面布局乱了，字体变大或者变小了。用调试工具打开进行调试的时候发现一个奇葩的问题：明明设置的100px的字体在APP中变成了86… 特别是iphone下，安卓部分是可用的。\r\n\r\n#### 问题因素\r\n\r\n1. 页面采用了rem单位，并且是采用js动态计算html的font-size \r\n\r\n2. 页面被加在了APP中的webview中  \r\n\r\n3. 这该死的手机被重设了字体大小 \r\n\r\n#### 解决方法  \r\n\r\n一般，我们动态计算好html的font-size之后，我们就啥都不干了，就走了。但是，我们现在知道了，我们设置的大小不一定是真实的大小，所以，我们需要在设置完字体大小之后，再去重新获取一下html的font-size，看看实际的这个值，和我们设置的是不是一样。如果不一样，就要根据比例再设置一次。直接抛代码！丢在入口文件即可。\r\n\r\n```\r\nfunction htmlFontSize(){\r\n    var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\r\n    var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\r\n    var width = w > h ? h : w;\r\n    width = width > 720 ? 720 : width\r\n    var fz = ~~(width*100000/36)/10000\r\n    document.getElementsByTagName(\"html\")[0].style.cssText = 'font-size: ' + fz +\"px\";\r\n    var realfz = ~~(+window.getComputedStyle(document.getElementsByTagName(\"html\")[0]).fontSize.replace('px','')*10000)/10000\r\n    if (fz !== realfz) {\r\n        document.getElementsByTagName(\"html\")[0].style.cssText = 'font-size: ' + fz * (fz / realfz) +\"px\";\r\n    }\r\n}\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/8",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/8/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/8/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/8/events",
            "html_url": "https://github.com/Will0319/blog/issues/8",
            "id": 352796143,
            "node_id": "MDU6SXNzdWUzNTI3OTYxNDM=",
            "number": 8,
            "title": "JavaScript 原型到原型链",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-22T04:06:02Z",
            "updated_at": "2018-12-23T09:12:57Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 构造函数创建对象\r\n\r\n```js\r\nfunction Person() {}\r\nvar person = new Person()\r\nperson.name = 'Dragon'\r\nconsole.log(person.name) // Dragon\r\n```\r\nPerson 就是一个构造函数，使用new实例化一个对象person\r\n\r\n### prototype\r\n\r\n每个函数都有一个prototype属性\r\n\r\n```js\r\nfunction Person() {}\r\n\r\nPerson.prototype.name = 'Dragon'\r\nvar person1 = new Person()\r\nvar person2 = new Person()\r\nconsole.log(person1.name)  // 'Dragon'\r\nconsole.log(person2.name)  // 'Dragon'\r\n```\r\n\r\n从上面可以发现person1和person2打印出的值都是 'Dragon', 到底函数prototype属性指向的是什么？  \r\n\r\n每一个JavaScript对象(null除外)在创建的时候就会关联另外一个对象，这个对象就是原型，每一个对象都会从原型继承属性。所以函数的prototype属性指向了一个对象，这个对象就是调用该构造函数实例化的原型，也就是person1和person2的原型。  \r\n\r\n![png](https://github.com/Will0319/ImgFile/blob/master/prototype/prototype1.png?raw=true)\r\n\r\n### __proto__ \r\n\r\n每一个JavaScript对象(除了null)都具有一个属性，叫__proto__，这个属性会指向该对象的原型。\r\n\r\n```js\r\nfunction Person() {}\r\nvar person = new Person()\r\nconsole.log(person.__proto__ === Person.prototype) // true\r\n```\r\n\r\n\r\n![png](https://github.com/Will0319/ImgFile/blob/master/prototype/prototype2.png?raw=true)\r\n\r\n如果实例对象和构造函数都可以指向原型，那么是否有属性可以指向构造函数或者实例？\r\n\r\n### constructor\r\n\r\n因为一个构造函数可以生成多个实例，所以指向实例是没有的。但是原型指向构造函数是有的，每个原型都有一个constructor属性指向关联的构造函数  \r\n\r\n```js\r\nfunction Person() {}\r\nconsole.log(Person === Person.prototype.constructor) // true\r\n```\r\n\r\n![png](https://github.com/Will0319/ImgFile/blob/master/prototype/prototype3.png?raw=true)\r\n\r\n所以:  \r\n\r\n```js\r\nfunction Person() {}\r\nvar person = new Person()\r\n\r\nconsole.log(person.__proto__ === Person.prototype) // ture\r\n\r\nconsole.log(Person.prototype.constructor === Person) // true\r\n\r\nconsole.log(Object.getPrototypeof(person) === Person.prototype) // true\r\n\r\n```\r\n\r\n\r\n### 实例和原型\r\n\r\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还找不到，就找原型中当原型，直到找到位置。  \r\n\r\n```js\r\nfunction Person() {}\r\n\r\nPerson.prototype.name = 'dragon'\r\n\r\nvar person = new Person()\r\nperson.name = 'dragon2'\r\nconsole.log(person.name) // dragon2\r\n\r\ndelete person.name\r\nconsole.log(person.name) // dragon\r\n```\r\n\r\n在这里，我们给person添加name属性，当打印person.name的时候，就会出现 dragon2   \r\n\r\n当删了perosn的name的时候，读取person.name在person对象中就找不到name的属性，那么person的原型就是person.__proto__，也就是Person.prototype中查找，索性是找到了。。。  \r\n\r\n如果没找到，那就要继续找，直到找到原型的原型啦～\r\n\r\n### 原型的原型\r\n\r\n```js\r\nvar obj = new Object()\r\nobj.name = 'dragon'\r\nconsole.log(obj.name) // dragon\r\n```\r\n\r\n所以原型对象就是通过Object构造函数生成的。\r\n\r\n![png](https://github.com/Will0319/ImgFile/blob/master/prototype/prototype4.png?raw=true)\r\n\r\n### 原型链\r\n\r\n```js\r\nconsole.log(Object.prototype.__proto__ === null) // true\r\n```\r\n所以Object.prototype.__proto__的值为null和Object.prototype没有原型是一样的，所以找到Object.prototype就不用继续找了\r\n\r\n![png](https://github.com/Will0319/ImgFile/blob/master/prototype/prototype5.png?raw=true)\r\n\r\n\r\n### 补充\r\n\r\n### constructor\r\n\r\n```js\r\nfunction Person() {}\r\nvar person = new Person()\r\nconsole.log(person.constructor === Person) // true\r\n```\r\n\r\n当获取person.constructor时候，person里面是没有constructor的，就会从person.prototype中获取,所以:\r\n\r\n```js\r\nPerson.constructor === Person.prototype.constructor\r\n```\r\n\r\n### __proto__\r\n\r\n__proto__不存在Person.prototype中，因为他来自于Object.prototype，可以当作是一个getter/setter,当使用到obj.__proto__时，可以理解成返回了Object.getPrototypeOf(obj)\r\n\r\n\r\n### 总结\r\n此文仅简单了解原型与原型链，深入待续…"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/7",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/7/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/7/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/7/events",
            "html_url": "https://github.com/Will0319/blog/issues/7",
            "id": 352796118,
            "node_id": "MDU6SXNzdWUzNTI3OTYxMTg=",
            "number": 7,
            "title": "Nginx基本配置和参数说明",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1032228032,
                    "node_id": "MDU6TGFiZWwxMDMyMjI4MDMy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Nginx",
                    "name": "Nginx",
                    "color": "8fefa6",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-22T04:05:51Z",
            "updated_at": "2018-12-19T06:38:05Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "### 一份简单的Nginx基本配置和参数说明 以备服务器配置调整\r\n\r\n```\r\n#运行用户\r\nuser angelasubi;\r\n#启动进程,通常设置成和cpu的数量相等\r\nworker_processes  1;\r\n \r\n#全局错误日志及PID文件\r\n#error_log  logs/error.log;\r\n#error_log  logs/error.log  notice;\r\n#error_log  logs/error.log  info;\r\n \r\n#pid        logs/nginx.pid;\r\n \r\n#工作模式及连接数上限\r\nevents {\r\n    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,\r\n    #仅用于linux2.6以上内核,可以大大提高nginx的性能\r\n    use   epoll; \r\n \r\n    #单个后台worker process进程的最大并发链接数    \r\n    worker_connections  1024;\r\n \r\n    # 并发总数是 worker_processes 和 worker_connections 的乘积\r\n    # 即 max_clients = worker_processes * worker_connections\r\n    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么\r\n    # 为什么上面反向代理要除以4，应该说是一个经验值\r\n    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000\r\n    # worker_connections 值的设置跟物理内存大小有关\r\n    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数\r\n    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右\r\n    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：\r\n    # $ cat /proc/sys/fs/file-max\r\n    # 输出 34336\r\n    # 32000 < 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内\r\n    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置\r\n    # 使得并发总数小于操作系统可以打开的最大文件数目\r\n    # 其实质也就是根据主机的物理CPU和内存进行配置\r\n    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。\r\n    # ulimit -SHn 65535\r\n \r\n}\r\n \r\n \r\nhttp {\r\n    #设定mime类型,类型由mime.type文件定义\r\n    include    mime.types;\r\n    default_type  application/octet-stream;\r\n    #设定日志格式\r\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\r\n                      '$status $body_bytes_sent \"$http_referer\" '\r\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\r\n \r\n    access_log  logs/access.log  main;\r\n \r\n    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\r\n    #对于普通应用，必须设为 on,\r\n    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\r\n    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\r\n    sendfile     on;\r\n    #tcp_nopush     on;\r\n \r\n    #连接超时时间\r\n    #keepalive_timeout  0;\r\n    keepalive_timeout  65;\r\n    tcp_nodelay     on;\r\n \r\n    #开启gzip压缩\r\n    gzip  on;\r\n    gzip_disable \"MSIE [1-6].\";\r\n \r\n    #设定请求缓冲\r\n    client_header_buffer_size    128k;\r\n    large_client_header_buffers  4 128k;\r\n \r\n \r\n    #设定虚拟主机配置\r\n    server {\r\n        #侦听80端口\r\n        listen    80;\r\n        #定义使用 www.nginx.cn访问\r\n        server_name  www.nginx.cn;\r\n \r\n        #定义服务器的默认网站根目录位置\r\n        root html;\r\n \r\n        #设定本虚拟主机的访问日志\r\n        access_log  logs/nginx.access.log  main;\r\n \r\n        #默认请求\r\n        location / {\r\n            \r\n            #定义首页索引文件的名称\r\n            index index.php index.html index.htm;   \r\n \r\n        }\r\n \r\n        # 定义错误提示页面\r\n        error_page   500 502 503 504 /50x.html;\r\n        location = /50x.html {\r\n        }\r\n \r\n        #静态文件，nginx自己处理\r\n        location ~ ^/(images|javascript|js|css|flash|media|static)/ {\r\n            \r\n            #过期30天，静态文件不怎么更新，过期可以设大一点，\r\n            #如果频繁更新，则可以设置得小一点。\r\n            expires 30d;\r\n        }\r\n \r\n        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\r\n        location ~ .php$ {\r\n            fastcgi_pass 127.0.0.1:9000;\r\n            fastcgi_index index.php;\r\n            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\r\n            include fastcgi_params;\r\n        }\r\n \r\n        #禁止访问 .htxxx 文件\r\n            location ~ /.ht {\r\n            deny all;\r\n        }\r\n \r\n    }\r\n}\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/6",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/6/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/6/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/6/events",
            "html_url": "https://github.com/Will0319/blog/issues/6",
            "id": 351850207,
            "node_id": "MDU6SXNzdWUzNTE4NTAyMDc=",
            "number": 6,
            "title": "浅谈React生命周期",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-18T20:36:53Z",
            "updated_at": "2018-11-29T01:45:42Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n谈一谈自己对生命周期的一些了解吧，在越是复杂逻辑的项目中，组件的生命周期是非常重要的，让组件更加的可以控制。\r\n******\r\n#### 组件的生命周期\r\n![组件的生命周期](https://github.com/Will0319/ImgFile/blob/master/react-lifecycle.png?raw=true)\r\n******\r\n#### 组件在初始化时会触发5个钩子函数：\r\n* 1、getDefaultProps()  \r\n>设置默认的props，也可以用dufaultProps设置组件的默认属性。\r\n* 2、getInitialState()  \r\n>在es6语法中可以直接state={}\r\n* 3、componentWillMount()  \r\n>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。\r\n* 4、 render()  \r\n>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。\r\n* 5、componentDidMount()  \r\n>组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。\r\n\r\n#### 在更新时也会触发5个钩子函数：\r\n* 6、componentWillReceiveProps(nextProps)  \r\n>组件初始化时不调用，组件接受新的props时调用。  \r\n* 7、shouldComponentUpdate(nextProps, nextState)  \r\n>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。  \r\n* 8、componentWillUpdate(nextProps, nextState)  \r\n>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state   \r\n* 9、render()  \r\n>与之前相同，当数据改变会重新调用  \r\n* 10、componentDidUpdate()  \r\n>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。  \r\n\r\n* 11、componentWillUnmount()  \r\n>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。  \r\n******\r\n#### 总结\r\nreact总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，熟练使用生命周期可以解决开发中一些很难处理的问题。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/5",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/5/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/5/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/5/events",
            "html_url": "https://github.com/Will0319/blog/issues/5",
            "id": 351847212,
            "node_id": "MDU6SXNzdWUzNTE4NDcyMTI=",
            "number": 5,
            "title": "对象组成的数组去重",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-18T20:00:05Z",
            "updated_at": "2018-08-19T13:48:29Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 使用数组的reduce()方法\r\n```\r\nlet data = [\r\n            { id: 201801, name: '张三', age: 15, },\r\n            { id: 201804, name: 'John', age: 18, },\r\n            { id: 201802, name: '李四', age: 18, },\r\n            { id: 201801, name: '张三', age: 15, },\r\n            { id: 201805, name: 'Jack', age: 18, },\r\n            { id: 201803, name: '王五', age: 10, },\r\n            { id: 201805, name: 'Jack', age: 18, },\r\n            { id: 201804, name: 'John', age: 18, },\r\n            { id: 201805, name: 'Jack', age: 18, },\r\n        ];\r\nlet hash = {}; \r\ndata = data.reduce((preVal, curVal) => {\r\n    hash[curVal.id] ? '' : hash[curVal.id] = true && preVal.push(curVal); \r\n    return preVal \r\n}, [])\r\nconsole.log( data, hash);\r\n```\r\n#### 上述方法的实现思路\r\n利用reduce()方法的累积器作用，在对由对象组成的数组进行遍历时，通过对象hash来标记数组中每个元素id是否出现过，如果出现过，那么遍历到的当前元素则不会放入到累积器中，如果没有出现，则添加到累积器中，这样保证了最后返回值中每个数据id的唯一性。\r\n#### 关于数组的reduce()方法\r\n官方解释：reduce()方法接收一个函数作为累积器，数组中的每个值从左到右开始合并，最后返回一个值。   \r\n我的理解：reduce()其实也就是对数组从左到右进行遍历，在遍历的同时按照回调函数中的方法进行处理，reduce()的特别之处是在于它每遍历一个元素之后会将这个元素放在累积器中累积起来，类似于收割机收小麦一样，从左往右收割，收割机中用来放收割好小麦的地方就类似于reduce()的累积器，最后满满收好的一大袋小麦就类似于reduce()的返回值。\r\n#### 语法\r\n```\r\narray.reduce(callbackfunction, initialVal);\r\nfunction callbackfunction(preVal, curVal, index, array){\r\n    //函数体\r\n}\r\n```\r\n数组的reduce()方法接收两个参数，callbackfunction回调函数和initialVal初始值；callbackfunction是必需项，initialVal是可选项；callbackfunction回调函数接收四个参数：   \r\npreVal —> 上一次调用回调函数返回的值，或者初始值initialVal；   \r\ncurVal —> 数组中当前被处理的值；   \r\nindex —> 当前的值在数组中的索引；   \r\narray —> 调用reduce()方法的数组；   \r\ncallbackfunction函数中必须有返回值，也就是累积器，它每次的返回值都是下一次调用回调函数中的preVal值。  \r\n<table>\r\n        <tr>\r\n            <th></th>\r\n            <th>preVal</th>\r\n            <th>curVal</th>\r\n            <th>index</th>\r\n            <th>array</th>\r\n            <th>返回值</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第一次回调</th>\r\n            <th>[ ]</th>\r\n            <th>data[1]</th>\r\n            <th>0</th>\r\n            <th>data</th>\r\n            <th>[ data[1] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第二次回调</th>\r\n            <th>[ data[1] ]</th>\r\n            <th>data[2]</th>\r\n            <th>1</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第三次回调</th>\r\n            <th>[ data[1], data[2] ]</th>\r\n            <th>data[3]</th>\r\n            <th>2</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第四次回调</th>\r\n            <th>[ data[1], data[2], data[3] ]</th>\r\n            <th>data[4]</th>\r\n            <th>3</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第五次回调</th>\r\n            <th>[ data[1], data[2], data[3] ]</th>\r\n            <th>data[5]</th>\r\n            <th>4</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3] , data[5] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第六次回调</th>\r\n            <th>[ data[1], data[2], data[3], data[5] ]</th>\r\n            <th>data[6]</th>\r\n            <th>5</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第七次回调</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n            <th>data[7]</th>\r\n            <th>6</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第八次回调</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n            <th>data[8]</th>\r\n            <th>7</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n        </tr>\r\n        <tr>\r\n            <th>第九次回调</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n            <th>data[9]</th>\r\n            <th>8</th>\r\n            <th>data</th>\r\n            <th>[ data[1], data[2], data[3], data[5], data[6] ]</th>\r\n        </tr>\r\n</table>    \r\n\r\n图解：从执行过程可以看出reduce()其实也就是遍历每个元素，只不过它在遍历下一个元素时会把上一次回调函数返回的值带入来进行相关操作。"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/4",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/4/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/4/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/4/events",
            "html_url": "https://github.com/Will0319/blog/issues/4",
            "id": 351838552,
            "node_id": "MDU6SXNzdWUzNTE4Mzg1NTI=",
            "number": 4,
            "title": "图片base64转码",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382702,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNzAy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Js",
                    "name": "Js",
                    "color": "e4e669",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-18T17:45:36Z",
            "updated_at": "2018-08-18T19:54:40Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n记录文件或者图片转base64方法。\r\n******\r\n#### 方法一：\r\nFileReader是一种异步文件读取机制。\r\n```\r\n/**\r\n * 使用FileReader获取图片Base64编码\r\n */\r\nconst reader = new FileReader();\r\nreader.readAsDataURL(fileList[0].originFileObj);\r\nreader.onload = function (e){\r\n      console.log(this.result)\r\n}\r\n```\r\n#### 方法二：\r\n利用Canvas画布截取转换。\r\n```\r\n/**\r\n * 使用Canvas获取图片Base64编码\r\n */\r\nfunction image2Base64(img) {\r\n    var canvas = document.createElement(\"canvas\");\r\n    canvas.width = img.width;\r\n    canvas.height = img.height;\r\n    var ctx = canvas.getContext(\"2d\");\r\n    ctx.drawImage(img, 0, 0, img.width, img.height);\r\n    var dataURL = canvas.toDataURL(\"image/png\");\r\n    return dataURL;\r\n}\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/3",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/3/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/3/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/3/events",
            "html_url": "https://github.com/Will0319/blog/issues/3",
            "id": 349815760,
            "node_id": "MDU6SXNzdWUzNDk4MTU3NjA=",
            "number": 3,
            "title": "markdown语法",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1019382697,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNjk3",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Markdown",
                    "name": "Markdown",
                    "color": "008672",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-12T14:11:54Z",
            "updated_at": "2018-08-24T16:12:16Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n既然是博客网站，那么肯定要用到MD语法，下面记录一下语法。\r\n******\r\n1、链接\r\n```\r\n [淘宝网](http://www.yx319.cn/)\r\n```\r\n2、图片\r\n```\r\n ![图片标题](http://yangxuan/319.png)\r\n```\r\n3、标题\r\n```\r\n # 一级标题\r\n ## 二级标题\r\n ### 三级标题\r\n #### 四级标题\r\n ##### 五级标题\r\n ###### 六级标题\r\n```\r\n4、斜体\r\n```\r\n *这是斜体*\r\n *[这是斜体链接](http://www.yx319.cn)*\r\n *斜体,[这是斜体链接](http://www.yx319.cn)*\r\n```\r\n5、字体颜色\r\n```\r\n这是<label style=\"color:red\">红色</label>字体\r\n这是<label style=\"color:green\">绿色</label>字体\r\n这是<label style=\"color:yellow\">黄色</label>字体\r\n这是<label style=\"color:blue\">蓝色</label>字体\r\n```\r\n6、字体加粗\r\n```\r\n**加粗**字体\r\n```\r\n7、Email\r\n```\r\nEmail:<41439753@qq.com>\r\n```\r\n8、无序排列\r\n```\r\n * list1\r\n * list2\r\n * list3\r\n```\r\n9、有序排列\r\n```\r\n 1. list1\r\n 2. list2\r\n 3. list3\r\n```\r\n10、分割线\r\n```\r\n******\r\n```\r\n11、内容框\r\n```\r\n在上一行内容缩进的基础上再缩进四个空格\r\n```\r\n12、换行\r\n```\r\n尾部两个空格\r\n```\r\n13、中划线\r\n```\r\n~~中划线~~\r\n```\r\n14、添加注脚\r\n```\r\n这是脚注[^1]\r\n[^1]: 这是脚注说明，会在文章的末尾显示.\r\n```\r\n15、表格\r\n```\r\n默认表格：\r\nFirst Header | Second Header | Third Header\r\n------------ | ------------- | ------------\r\nContent Cell | Content Cell  | Content Cell\r\nContent Cell | Content Cell  | Content Cell\r\n\r\n左右浮动表格：\r\nFirst Header | Second Header | Third Header\r\n:----------- | :-----------: | -----------:\r\nLeft         | Center        | Right\r\nLeft         | Center        | Right\r\n```\r\n16、内容块\r\n```\r\n> 这里的内容在内容块中\r\n```\r\n\r\n"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/2",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/2/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/2/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/2/events",
            "html_url": "https://github.com/Will0319/blog/issues/2",
            "id": 349081904,
            "node_id": "MDU6SXNzdWUzNDkwODE5MDQ=",
            "number": 2,
            "title": "首屏加载速度优化",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1032228032,
                    "node_id": "MDU6TGFiZWwxMDMyMjI4MDMy",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/Nginx",
                    "name": "Nginx",
                    "color": "8fefa6",
                    "default": false
                },
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                },
                {
                    "id": 1019382694,
                    "node_id": "MDU6TGFiZWwxMDE5MzgyNjk0",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/%E4%BC%98%E5%8C%96",
                    "name": "优化",
                    "color": "ed7496",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-09T11:09:23Z",
            "updated_at": "2018-08-24T11:23:17Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n一开始博客上线的时候加载了30s-40s，一度以为网站挂掉了，原因是项目首次加载的JS文件过大了。于是进行了一些优化。目前使用的首屏加载速度有五种，还有其他优化的方法的话会在此继续更新。\r\n******\r\n#### 一、通过webpack的UglifyJsPlugin插件对代码进行压缩\r\n通过简单的UglifyJsPlugin配置可以将代码压缩至原来的一半大小\r\n```\r\nnew webpack.optimize.UglifyJsPlugin({\r\n            compress: {\r\n                warnings: false\r\n            }\r\n})\r\n```\r\n#### 二、通过服务器对代码进行gzip压缩\r\n开启nginx gzip压缩后，网页、css、js等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。但是会消耗cpu资源。  \r\n开启的配置如下：\r\n```\r\ngzip  on;  #开启gzip\r\ngzip_min_length 1k;  #低于1kb的资源不压缩\r\ngzip_comp_level 3; #压缩级别【1-9】，越大压缩率越高，同时消耗cpu资源也越多。\r\ngzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css;  #需要压缩哪些响应类型的资源，多个空格隔开。\r\n```\r\n此处不建议压缩图片，因为如jpg、png本身就会有压缩，所以就算开启gzip后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。\r\n#### 三、使用异步组件实现懒加载JS\r\n使用asyncComponent函数：函数很好理解，loadComponent参数表示需要代码切割的路径，函数返回值是一个react组件，组件内部帮你做好了then()方法的操作。\r\n* asyncComponent文件\r\n\r\n```\r\nimport React, { Component } from \"react\";\r\nimport {Spin} from 'antd';\r\nexport default function asyncComponent(importComponent) {\r\n    class AsyncComponent extends Component {\r\n        constructor(props) {\r\n            super(props);\r\n            this.state = {\r\n                component: null\r\n            };\r\n        }\r\n        async componentDidMount() {\r\n            const { default: component } = await importComponent();\r\n            this.setState({\r\n                component: component\r\n            });\r\n        }\r\n        render() {\r\n            const Component = this.state.component;\r\n            return Component ? <Component {...this.props} /> : <Spin size='large' tip=\"Loading...\"/>\r\n        }\r\n    }\r\n    return AsyncComponent;\r\n}\r\n```\r\n* 在React路由中引入\r\n\r\n```\r\nimport { asyncComponent } from './AsyncComponent'\r\nconst Foo = asyncComponent(() => import('文件路径'))\r\n<Route path=\"/xx\" component={Foo} />\r\n```\r\n\r\n#### 四、提取第三方库\r\n像 react , redux，antd之类的库和我们的源代码放在一起打包，体积肯定会很大。所以可以在 webpack 中设置：\r\n```\r\nentry:{\r\n        vendor:['react','redux']\r\n    },\r\nplugins: [\r\n        new webpack.optimize.CommonsChunkPlugin('vendor',  'vendor.js')\r\n  ]\r\n```\r\n这样我们只需要在html中引入vendor.js就行了\r\n#### 五、Antd按需加载\r\n打开webpack.config中做如下配置\r\n```\r\n{\r\n  test: /\\.(js|jsx|mjs)$/,\r\n  include: paths.appSrc,\r\n  loader: require.resolve('babel-loader'),\r\n  options: {\r\n     plugins: [\r\n     ['import', [{ libraryName: 'antd', style: true }]],  // import less\r\n     ],\r\n  cacheDirectory: true,\r\n}\r\n```"
        },
        {
            "url": "https://api.github.com/repos/Will0319/blog/issues/1",
            "repository_url": "https://api.github.com/repos/Will0319/blog",
            "labels_url": "https://api.github.com/repos/Will0319/blog/issues/1/labels{/name}",
            "comments_url": "https://api.github.com/repos/Will0319/blog/issues/1/comments",
            "events_url": "https://api.github.com/repos/Will0319/blog/issues/1/events",
            "html_url": "https://github.com/Will0319/blog/issues/1",
            "id": 349081509,
            "node_id": "MDU6SXNzdWUzNDkwODE1MDk=",
            "number": 1,
            "title": "初次见面",
            "user": {
                "login": "Will0319",
                "id": 40861927,
                "node_id": "MDQ6VXNlcjQwODYxOTI3",
                "avatar_url": "https://avatars3.githubusercontent.com/u/40861927?v=4",
                "gravatar_id": "",
                "url": "https://api.github.com/users/Will0319",
                "html_url": "https://github.com/Will0319",
                "followers_url": "https://api.github.com/users/Will0319/followers",
                "following_url": "https://api.github.com/users/Will0319/following{/other_user}",
                "gists_url": "https://api.github.com/users/Will0319/gists{/gist_id}",
                "starred_url": "https://api.github.com/users/Will0319/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Will0319/subscriptions",
                "organizations_url": "https://api.github.com/users/Will0319/orgs",
                "repos_url": "https://api.github.com/users/Will0319/repos",
                "events_url": "https://api.github.com/users/Will0319/events{/privacy}",
                "received_events_url": "https://api.github.com/users/Will0319/received_events",
                "type": "User",
                "site_admin": false
            },
            "labels": [
                {
                    "id": 1025853396,
                    "node_id": "MDU6TGFiZWwxMDI1ODUzMzk2",
                    "url": "https://api.github.com/repos/Will0319/blog/labels/React",
                    "name": "React",
                    "color": "67DBFA",
                    "default": false
                }
            ],
            "state": "open",
            "locked": false,
            "assignee": null,
            "assignees": [],
            "milestone": null,
            "comments": 0,
            "created_at": "2018-08-09T11:08:04Z",
            "updated_at": "2018-12-23T16:32:50Z",
            "closed_at": null,
            "author_association": "OWNER",
            "body": "#### 前言\r\n已经学习并且使用react有一段时间了，于是就想用最近学的一些技术搭建一个博客记录一下自己成长。\r\n******\r\n#### 使用技术栈\r\n* react (v16) ：项目主框架\r\n* redux：状态管理\r\n* react-router v4：前端路由\r\n* es6：项目中用到的语法\r\n* webpack3：打包工具\r\n* antd：前端UI框架\r\n* Axios：异步请求数据\r\n* eslint：代码规范检查\r\n******\r\n#### 部署开发环境\r\n* 安装node    \r\n 官方下载地址：https://nodejs.org/en/\r\n* 安装yarn  \r\n\r\n```\r\n//首先如果没有Homebrew包管理工具需要先下载此工具\r\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\r\n//通过Homebrew安装yarn\r\nbrew install yarn\r\n//设置yarn为全局变量\r\nexport PATH=\"$PATH:`yarn global bin`\"\r\n```\r\n* 全局安装官方脚手架create-react-app\r\n\r\n```\r\n//安装\r\nnpm install -g create-react-app\r\n//创建项目\r\ncreate-react-app blog\r\n//打开项目\r\nyarn start\r\n```\r\n\r\n#### 项目UI框架\r\n使用的是Antd 使用方法在官网有很详细的介绍：https://ant.design/index-cn\r\n#### 数据源\r\n此次博客数据源来自于issues  \r\nAPI在这：https://developer.github.com/v3/issues/\r\n#### markdown 渲染  \r\n在git上查找如何渲染md文档有两个库可以使用  \r\n*  react-markdown：https://github.com/rexxars/react-markdown  \r\n*  marked：https://github.com/chjj/marked  \r\n这里主要介绍一下本次博客使用的marked的使用方法\r\n\r\n```\r\nimport marked from 'marked';\r\ncomponentWillMount(){\r\n    marked.setOptions({\r\n    highlight: code => hljs.highlightAuto(code).value,\r\n    });\r\n}\r\n//把字符串插入DOM元素中\r\n<div dangerouslySetInnerHTML={{ __html: 文档字符串 }} />\r\n```\r\n\r\n#### 代码高亮\r\n代码高亮用的是highlight.js：https://github.com/isagalaev/highlight.js  \r\n它和marked可以无缝衔接~  \r\n只需要这样既可：  \r\n```\r\nimport hljs from 'highlight.js';\r\nmarked.setOptions({\r\n  highlight: code => hljs.highlightAuto(code).value,\r\n});\r\n```\r\nhighlight.js是支持多种代码配色风格的，可以在css文件中进行切换：  \r\n```\r\n@import '~highlight.js/styles/atom-one-dark.css';\r\n```\r\n在这可以看到每种语言的高亮效果和配色风格：https://highlightjs.org/\r\n#### 项目上线\r\n该博客是Nginx实现静态资源服务器的，下面讲一下如何在服务器上搭建静态网站，以及静态部署。\r\n* 打包项目\r\n\r\n```\r\ncd 项目文件夹\r\nyarn build\r\n```\r\n* 服务器上安装Nginx\r\n\r\n```\r\nyum install nginx -y\r\n```\r\n* 运行Nginx\r\n\r\n```\r\nnginx\r\n```\r\n这个时候访问你的网站就可以看到Nginx的测试页面啦~\r\n* 配置静态服务器的访问地址  \r\n打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置，将默认的root /usr/share/nginx/html; 修改为: root /data/www;如下：\r\n\r\n\r\n```\r\nlisten       80 default_server;\r\nlisten       [::]:80 default_server;\r\nserver_name  _;\r\nroot         /data/www/你的项目文件;\r\n```\r\n\r\n* 重启Nginx生效配置\r\n\r\n```\r\nnginx -s reload\r\n```\r\n此时访问你的地址就能够看到项目啦！\r\n******\r\n#### 后记\r\n目前的项目还有很多未完善的，之后慢慢改进这个项目吧。  \r\n(ง •̀_•́)ง "
        }
    ]
}